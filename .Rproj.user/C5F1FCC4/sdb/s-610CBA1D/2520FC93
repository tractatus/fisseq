{
    "collab_server" : "",
    "contents" : "/*\n * libics: Image Cytometry Standard file reading and writing.\n *\n * Copyright (C) 2000-2010 Cris Luengo and others\n * email: clluengo@users.sourceforge.net\n *\n * Large chunks of this library written by\n *    Bert Gijsbers\n *    Dr. Hans T.M. van der Voort\n * And also Damir Sudar, Geert van Kempen, Jan Jitze Krol,\n * Chiel Baarslag and Fons Laan.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the Free\n * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n/*\n * FILE : libics.h\n *\n * This is the main include file, and the only file you need to include in your\n * source code if you use the top-level functions in this library.\n */\n\n#ifndef LIBICS_H\n#define LIBICS_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ICSLIB_VERSION \"1.5.2\" /* also defined in configure.in */\n\n#if defined(__WIN32__) && !defined(WIN32)\n#define WIN32\n#endif\n\n#ifdef WIN32\n/*** Windows Specifics ***/\n\n#ifdef BUILD_ICSLIB\n#define ICSEXPORT __declspec(dllexport)\n#else\n#ifdef USE_ICSLIB_DLL\n#define ICSEXPORT __declspec(dllimport)\n#else\n#define ICSEXPORT\n#endif\n#endif\n\n/*** End of Windows Specifics ***/\n#else\n\n#define ICSEXPORT\n\n#endif\n\n/* For the moment the largest imel is a double complex of 16 bytes: */\n#define ICS_MAX_IMEL_SIZE 16\n\n/* These determine the sizes of static arrays and strings: */\n#define ICS_MAXDIM 10        /* number of allowed dimensions in the image */\n#define ICS_MAX_LAMBDA 16    /* number of allowed sensor channels */\n#define ICS_STRLEN_TOKEN 20  /* length of a token string */\n#define ICS_STRLEN_OTHER 128 /* length of other strings */\n#define ICS_LINE_LENGTH 256  /* the maximum length of each of the lines in the .ics file. */\n#define ICS_MAXPATHLEN 512   /* the maximum length of the file names */\n\n/*\n * These are the known data types for imels. If you use another type,\n * you can't use the top-level functions:\n */\ntypedef enum {\n    Ics_unknown = 0,\n    Ics_uint8,          /* integer, unsigned,  8 bpp */\n    Ics_sint8,          /* integer, signed,    8 bpp */\n    Ics_uint16,         /* integer, unsigned, 16 bpp */\n    Ics_sint16,         /* integer, signed,   16 bpp */\n    Ics_uint32,         /* integer, unsigned, 32 bpp */\n    Ics_sint32,         /* integer, signed,   32 bpp */\n    Ics_real32,         /* real,    signed,   32 bpp */\n    Ics_real64,         /* real,    signed,   64 bpp */\n    Ics_complex32,      /* complex, signed, 2*32 bpp */\n    Ics_complex64       /* complex, signed, 2*64 bpp */\n} Ics_DataType;\n\n/*\n * These are the compression methods supported by this library:\n */\ntypedef enum {\n    IcsCompr_uncompressed = 0, /* No compression */\n    IcsCompr_compress,         /* Using 'compress' (but when writing converted to gzip) */\n    IcsCompr_gzip              /* Using Zlib (ICS_ZLIB must be defined) */\n} Ics_Compression;\n\n/*\n * These are the file modes:\n */\ntypedef enum {\n    IcsFileMode_write,   /* Write mode */\n    IcsFileMode_read,    /* Read mode */\n    IcsFileMode_update   /* Read-Write mode: change only meta-data, read any header item */\n} Ics_FileMode;\n\n/*\n * These are structures that define the image representation. They are\n * only used inside the ICS data structure:\n */\ntypedef struct {\n    size_t Size;                               /* Number of imels in this dimension */\n    double Origin;                             /* Position of first imel */\n    double Scale;                              /* Distance between imels */\n    char Order[ICS_STRLEN_TOKEN];              /* Order of this dimension */\n    char Label[ICS_STRLEN_TOKEN];              /* Label for this dimension */\n    char Unit[ICS_STRLEN_TOKEN];               /* Units for Origin and Scale */\n} Ics_DataRepresentation;\n\ntypedef struct {\n    Ics_DataType DataType;                     /* Numeric representation for the imels */\n    size_t SigBits;                            /* Number of significant bits */\n    double Origin;                             /* Offset for imel values */\n    double Scale;                              /* Scaling for imel values */\n    char Unit[ICS_STRLEN_TOKEN];               /* Units for Origin and Scale */\n    /* Order is always \"bits\", Label is always \"intensity\" */\n} Ics_ImelRepresentation;\n\n/*\n * This is the data structure that holds all the information in\n *  the ICS file:\n */\ntypedef struct _ICS {\n    int Version;                               /* ICS version: 1 for v.1.0, 2 for v.2.0 */\n    Ics_FileMode FileMode;                     /* How the ICS file was opened. Used by top-level only */\n    void const* Data;                          /* Pointer to the data to write */\n    size_t DataLength;                         /* Size of the data buffer */\n    size_t const* DataStrides;                 /* Distance in pixels to the neighbors (writing only) */\n    char Filename[ICS_MAXPATHLEN];             /* '.ics' filename (including path) */\n    int Dimensions;                            /* Number of elements in Dim */\n    Ics_DataRepresentation Dim[ICS_MAXDIM];    /* Image representaion */\n    Ics_ImelRepresentation Imel;               /* Imel representation */\n    char Coord[ICS_STRLEN_TOKEN];              /* Coordinate system used */\n    Ics_Compression Compression;               /* Compression technique used */\n    int CompLevel;                             /* Parameter for the compression */\n    int ByteOrder[ICS_MAX_IMEL_SIZE];          /* Byte storage order */\n    void* History;                             /* History strings */\n\n    /* To read the data in blocks we need this: */\n    void* BlockRead;                           /* Contains the status of the data file */\n\n    /* New ICS v. 2.0 parameters: */\n    char SrcFile[ICS_MAXPATHLEN];              /* Source file name */\n    size_t SrcOffset;                          /* Offset into source file */\n\n    /* Special microscopic parameters: */\n    int WriteSensor;                           /* Set to 1 if the next params are needed */\n    char Type[ICS_STRLEN_TOKEN];               /* sensor type */\n    char Model[ICS_STRLEN_OTHER];              /* model or make */\n    int SensorChannels;                        /* Number of channels */\n    double PinholeRadius[ICS_MAX_LAMBDA];      /* Backprojected microns */\n    double LambdaEx[ICS_MAX_LAMBDA];           /* Excitation wavelength in nanometers */\n    double LambdaEm[ICS_MAX_LAMBDA];           /* Emission wavelength in nm */\n    int ExPhotonCnt[ICS_MAX_LAMBDA];           /* # of excitation photons */\n    double RefrInxMedium;                      /* Refractive index of embedding medium */\n    double NumAperture;                        /* Numerical Aperture */\n    double RefrInxLensMedium;                  /* Refractive index of design medium */\n    double PinholeSpacing;                     /* Nipkow Disk pinhole spacing */\n\n    /* SCIL_Image compatibility parameter */\n    char ScilType[ICS_STRLEN_TOKEN];           /* SCIL_TYPE string */\n} ICS;\n\n/* These are the error codes: */\ntypedef enum {\n    IcsErr_Ok = 0,\n    IcsErr_FSizeConflict,       /* Non fatal error: unexpected data size */\n    IcsErr_OutputNotFilled,     /* Non fatal error: the output buffer could not be completely filled (meaning that your buffer was too large) */\n    IcsErr_Alloc,               /* Memory allocation error */\n    IcsErr_BitsVsSizeConfl,     /* Image size conflicts with bits per element */\n    IcsErr_BlockNotAllowed,     /* It is not possible to read COMPRESS-compressed data in blocks */\n    IcsErr_BufferTooSmall,      /* The buffer was too small to hold the given ROI */\n    IcsErr_CompressionProblem,  /* Some error occurred during compression */\n    IcsErr_CorruptedStream,     /* The compressed input stream is currupted */\n    IcsErr_DecompressionProblem,/* Some error occurred during decompression */\n    IcsErr_DuplicateData,       /* The ICS data structure already contains incompatible stuff */\n    IcsErr_EmptyField,          /* Empty field (intern error) */\n    IcsErr_EndOfHistory,        /* All history lines have already been returned */\n    IcsErr_EndOfStream,         /* Unexpected end of stream */\n    IcsErr_FCloseIcs,           /* File close error on .ics file */\n    IcsErr_FCloseIds,           /* File close error on .ids file */\n    IcsErr_FCopyIds,            /* Failed to copy image data from temporary file on .ics file opened for updating */\n    IcsErr_FOpenIcs,            /* File open error on .ics file */\n    IcsErr_FOpenIds,            /* File open error on .ids file */\n    IcsErr_FReadIcs,            /* File read error on .ics file */\n    IcsErr_FReadIds,            /* File read error on .ids file */\n    IcsErr_FTempMoveIcs,        /* Failed to remane .ics file opened for updating */\n    IcsErr_FWriteIcs,           /* File write error on .ics file */\n    IcsErr_FWriteIds,           /* File write error on .ids file */\n    IcsErr_FailWriteLine,       /* Failed to write a line in .ics file */\n    IcsErr_IllIcsToken,         /* Illegal ICS token detected */\n    IcsErr_IllParameter,        /* A function parameter has a value that is not legal or does not match with a value previously given */\n    IcsErr_IllegalROI,          /* The given ROI extends outside the image */\n    IcsErr_LineOverflow,        /* Line overflow in ics file */\n    IcsErr_MissBits,            /* Missing \"bits\" element in .ics file */\n    IcsErr_MissCat,             /* Missing main category */\n    IcsErr_MissLayoutSubCat,    /* Missing layout subcategory */\n    IcsErr_MissParamSubCat,     /* Missing parameter subcategory */\n    IcsErr_MissRepresSubCat,    /* Missing representation subcategory */\n    IcsErr_MissSensorSubCat,    /* Missing sensor subcategory */\n    IcsErr_MissSensorSubSubCat, /* Missing sensor subsubcategory */\n    IcsErr_MissSubCat,          /* Missing sub category */\n    IcsErr_MissingData,         /* There is no Data defined */\n    IcsErr_NoLayout,            /* Layout parameters missing or not defined */\n    IcsErr_NoScilType,          /* There doesn't exist a SCIL_TYPE value for this image */\n    IcsErr_NotIcsFile,          /* Not an ICS file */\n    IcsErr_NotValidAction,      /* The function won't work on the ICS given */\n    IcsErr_TooManyChans,        /* Too many channels specified */\n    IcsErr_TooManyDims,         /* Data has too many dimensions */\n    IcsErr_UnknownCompression,  /* Unknown compression type */\n    IcsErr_UnknownDataType,     /* The datatype is not recognized */\n    IcsErr_WrongZlibVersion     /* libics is linking to a different version of zlib than used during compilation */\n} Ics_Error;\n\n/* Used by IcsGetHistoryString */\ntypedef enum {\n    IcsWhich_First,             /* Get the first string */\n    IcsWhich_Next               /* Get the next string */\n} Ics_HistoryWhich;\n\ntypedef struct {\n    int next;                     /* index into history array, pointing to next string to read,\n                                     set to -1 if there's no more to read. */\n    int previous;                 /* index to previous string, useful for relace and delete. */\n    char key[ICS_STRLEN_TOKEN+1]; /* optional key this iterator looks for. */\n} Ics_HistoryIterator;\n\n/*\n * Function declarations and short explanation:\n */\n\nICSEXPORT char const* IcsGetLibVersion (void);\n/* Returns a string that can be used to compare with ICSLIB_VERSION to check\n * if the version of the library is the same as that of the headers. */\n\nICSEXPORT int IcsVersion (char const* filename, int forcename);\n/* Returns 0 if it is not an ICS file, or the version number if it is.\n * If forcename is non-zero, no extension is appended. */\n\nICSEXPORT Ics_Error IcsLoadPreview (char const* filename, size_t planenumber,\n                                    void** dest, size_t* xsize, size_t* ysize);\n/* Read a preview (2D) image out of an ICS file. The buffer is malloc'd, xsize\n * and ysize are set to the image size. The data type is always uint8. You need\n * to free() the data block when you're done. */\n\nICSEXPORT Ics_Error IcsOpen (ICS* *ics, char const* filename, char const* mode);\n/* Open an ICS file for reading (mode = \"r\") or writing (mode = \"w\").\n * When writing, append a \"2\" to the mode string to create an ICS version\n * 2.0 file. Append an \"f\" to mode if, when reading, you want to force the file\n * name to not change (no \".ics\" is appended). Append a \"l\" to mode if, when\n * reading, you don't want the locale forced to \"C\" (to read ICS files written\n * with some other locale, set the locale properly then open the file with \"rl\") */\n\nICSEXPORT Ics_Error IcsClose (ICS* ics);\n/* Close the ICS file. The ics 'stream' is no longer valid after this.\n * No files are actually written until this function is called. */\n\nICSEXPORT Ics_Error IcsGetLayout (ICS const* ics, Ics_DataType* dt, int* ndims, size_t* dims);\n/* Retrieve the layout of an ICS image. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsSetLayout (ICS* ics, Ics_DataType dt, int ndims, size_t const* dims);\n/* Set the layout for an ICS image. Only valid if writing. */\n\nICSEXPORT size_t IcsGetDataSize (ICS const* ics);\nICSEXPORT size_t IcsGetImelSize (ICS const* ics);\nICSEXPORT size_t IcsGetImageSize (ICS const* ics);\n/* These three functions retrieve info from the ICS file.\n * IcsGetDataSize(ics) == IcsGetImelSize(ics) * IcsGetImageSize(ics) */\n\nICSEXPORT Ics_Error IcsGetData (ICS* ics, void* dest, size_t n);\n/* Read the image data from an ICS file. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsGetROIData (ICS* ics, size_t const* offset,\n                                   size_t const* size, size_t const* sampling,\n                                   void* dest, size_t n);\n/* Read a square region of the image from an ICS file. To use the defaults\n * in one of the parameters, set the pointer to NULL. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsGetDataWithStrides (ICS* ics, void* dest, size_t n,\n                                           size_t const* stride, int ndims);\n/* Read the image from an ICS file into a sub-block of a memory block. To\n * use the defaults in one of the parameters, set the pointer to NULL. Only\n * valid if reading. */\n\nICSEXPORT Ics_Error IcsGetDataBlock (ICS* ics, void* dest, size_t n);\n/* Read a portion of the image data from an ICS file. Only valid if\n * reading. */\n\nICSEXPORT Ics_Error IcsSkipDataBlock (ICS* ics, size_t n);\n/* Skip a portion of the image from an ICS file. Only valid if\n * reading. */\n\nICSEXPORT Ics_Error IcsGetPreviewData (ICS* ics, void* dest, size_t n,\n                                       size_t planenumber);\n/* Read a plane of the image data from an ICS file, and convert it\n * to uint8. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsSetData (ICS* ics, void const* src, size_t n);\n/* Set the image data for an ICS image. The pointer to this data must\n * be accessible until IcsClose has been called. Only valid if writing. */\n\nICSEXPORT Ics_Error IcsSetDataWithStrides (ICS* ics, void const* src, size_t n,\n                                           size_t const* strides, int ndims);\n/* Set the image data for an ICS image. The pointer to this data must\n * be accessible until IcsClose has been called. Only valid if writing. */\n\nICSEXPORT Ics_Error IcsSetSource (ICS* ics, char const* fname, size_t offset);\n/* Set the image source parameter for an ICS version 2.0 file. Only\n * valid if writing. */\n\nICSEXPORT Ics_Error IcsSetCompression (ICS* ics, Ics_Compression compression, int level);\n/* Set the compression method and compression parameter. Only valid if writing. */\n\nICSEXPORT Ics_Error IcsGetPosition (ICS const* ics, int dimension, double* origin,\n                                    double* scale, char* units);\n/* Get the position of the image in the real world: the origin of the first\n * pixel, the distances between pixels and the units in which to measure.\n * If you are not interested in one of the parameters, set the pointer to NULL.\n * Dimensions start at 0. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsSetPosition (ICS* ics, int dimension, double origin,\n                                    double scale, char const* units);\n/* Set the position of the image in the real world: the origin of the first\n * pixel, the distances between pixels and the units in which to measure.\n * If units is NULL or empty, it is set to the default value of \"undefined\".\n * Dimensions start at 0. Only valid if writing. */\n\nICSEXPORT Ics_Error IcsGetOrder (ICS const* ics, int dimension, char* order, char* label);\n/* Get the ordering of the dimensions in the image. The ordering is defined\n * by names and labels for each dimension. The defaults are x, y, z, t (time)\n * and p (probe). Dimensions start at 0. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsSetOrder (ICS* ics, int dimension, char const* order,\n                                 char const* label);\n/* Set the ordering of the dimensions in the image. The ordering is defined\n * by providing names and labels for each dimension. The defaults are\n * x, y, z, t (time) and p (probe). Dimensions start at 0. Only valid if writing. */\n\nICSEXPORT Ics_Error IcsGetCoordinateSystem (ICS const* ics, char* coord);\n/* Get the coordinate system used in the positioning of the pixels.\n * Related to IcsGetPosition(). The default is \"video\". Only valid if\n * reading. */\n\nICSEXPORT Ics_Error IcsSetCoordinateSystem (ICS* ics, char const* coord);\n/* Set the coordinate system used in the positioning of the pixels.\n * Related to IcsSetPosition(). The default is \"video\". Only valid if\n * writing. */\n\nICSEXPORT Ics_Error IcsGetSignificantBits (ICS const* ics, size_t* nbits);\n/* Get the number of significant bits. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsSetSignificantBits (ICS* ics, size_t nbits);\n/* Set the number of significant bits. Only valid if writing. */\n\nICSEXPORT Ics_Error IcsGetImelUnits (ICS const* ics, double* origin, double* scale, char* units);\n/* Set the position of the pixel values: the offset and scaling, and the\n * units in which to measure. If you are not interested in one of the\n * parameters, set the pointer to NULL. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsSetImelUnits (ICS* ics, double origin, double scale, char const* units);\n/* Set the position of the pixel values: the offset and scaling, and the\n * units in which to measure. If units is NULL or empty, it is set to the\n * default value of \"relative\". Only valid if writing. */\n\nICSEXPORT Ics_Error IcsGetScilType (ICS const* ics, char* sciltype);\n/* Get the string for the SCIL_TYPE parameter. This string is used only\n * by SCIL_Image. Only valid if reading. */\n\nICSEXPORT Ics_Error IcsSetScilType (ICS* ics, char const* sciltype);\n/* Set the string for the SCIL_TYPE parameter. This string is used only\n * by SCIL_Image. It is required if you want to read the image using\n * SCIL_Image. Only valid if writing. */\n\nICSEXPORT Ics_Error IcsGuessScilType (ICS* ics);\n/* As IcsSetScilType, but creates a string according to the DataType\n * in the ICS structure. It can create a string for g2d, g3d, f2d, f3d,\n * c2d and c3d. Only valid if writing. */\n\nICSEXPORT char const* IcsGetErrorText (Ics_Error error);\n/* Returns a textual representation of an error. */\n\nICSEXPORT Ics_Error IcsAddHistoryString (ICS* ics, char const* key, char const* value);\n/* Add history lines to the ICS file. key can be NULL */\n#define IcsAddHistory IcsAddHistoryString\n\nICSEXPORT Ics_Error IcsDeleteHistory (ICS* ics, char const* key);\n/* Delete all history lines with key from ICS file. key can be NULL,\n * deletes all. */\n\nICSEXPORT Ics_Error IcsGetNumHistoryStrings (ICS* ics, int* num);\n/* Get the number of HISTORY lines from the ICS file. */\n\nICSEXPORT Ics_Error IcsGetHistoryString (ICS* ics, char* string,\n                                         Ics_HistoryWhich which);\n/* Get history line from the ICS file. string must have at least\n * ICS_LINE_LENGTH characters allocated. */\n\nICSEXPORT Ics_Error IcsGetHistoryKeyValue (ICS* ics, char* key, char* value,\n                                           Ics_HistoryWhich which);\n/* Get history line from the ICS file as key/value pair. key must have\n * ICS_STRLEN_TOKEN characters allocated, and value ICS_LINE_LENGTH.\n * key can be null, token will be discarded. */\n\nICSEXPORT Ics_Error IcsNewHistoryIterator (ICS* ics, Ics_HistoryIterator* it, char const* key);\n/* Initializes history iterator. key can be NULL. */\n\nICSEXPORT Ics_Error IcsGetHistoryStringI (ICS* ics, Ics_HistoryIterator* it, char* string);\n/* Get history line from the ICS file using iterator. string must have at\n * least ICS_LINE_LENGTH characters allocated. */\n\nICSEXPORT Ics_Error IcsGetHistoryKeyValueI (ICS* ics, Ics_HistoryIterator* it,\n                                            char* key, char* value);\n/* Get history line from the ICS file as key/value pair using iterator.\n * key must have ICS_STRLEN_TOKEN characters allocated, and value\n * ICS_LINE_LENGTH. key can be null, token will be discarded. */\n\nICSEXPORT Ics_Error IcsDeleteHistoryStringI (ICS* ics, Ics_HistoryIterator* it);\n/* Delete last retrieved history line (iterator still points to the same string). */\n\nICSEXPORT Ics_Error IcsReplaceHistoryStringI (ICS* ics, Ics_HistoryIterator* it,\n                                              char const* key, char const* value);\n/* Delete last retrieved history line (iterator still points to the same string). */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* LIBICS_H */\n",
    "created" : 1476130100637.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3856135127",
    "id" : "2520FC93",
    "lastKnownWriteTime" : 1276847157,
    "last_content_update" : 1276847157,
    "path" : "~/GitHub/fisseq/src/libics.h",
    "project_path" : "src/libics.h",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "h"
}