{
    "collab_server" : "",
    "contents" : "/*\n* CThinPlateSpline.cpp\n*\n*  Created on: 24.01.2010\n*      Author: schmiedm\n*/\n\n#include <vector>\n#include \"opencv2/opencv.hpp\"\n#include \"opencv2/opencv_modules.hpp\"\n#include \"opencv2/highgui/highgui.hpp\"\n#include \"opencv2/imgproc/imgproc.hpp\"\n#include \"CThinPlateSpline.h\"\nusing namespace cv;\n\nCThinPlateSpline::CThinPlateSpline() {\n\tFLAG_MAPS_FORWARD_SET = false;\n\tFLAG_MAPS_BACK_WARP_SET = false;\n\tFLAG_COEFFS_BACK_WARP_SET = false;\n\tFLAG_COEFFS_FORWARD_WARP_SET = false;\n}\n\nCThinPlateSpline::CThinPlateSpline(const std::vector<Point>& pS, const std::vector<Point>& pD)\n{\n\tif(pS.size() == pS.size())\n\t{\n\t\tpSrc = pS;\n\t\tpDst = pD;\n\t}\n\n\tFLAG_MAPS_FORWARD_SET = false;\n\tFLAG_MAPS_BACK_WARP_SET = false;\n\tFLAG_COEFFS_BACK_WARP_SET = false;\n\tFLAG_COEFFS_FORWARD_WARP_SET = false;\n}\n\nCThinPlateSpline::~CThinPlateSpline() {\n}\n\nvoid CThinPlateSpline::addCorrespondence(const Point& pS, const Point& pD)\n{\n\tpSrc.push_back(pS);\n\tpDst.push_back(pD);\n\n\t// tell the class to recompute the coefficients if neccesarry \n\tFLAG_COEFFS_BACK_WARP_SET = false;\n\tFLAG_COEFFS_FORWARD_WARP_SET = false;\n\tFLAG_MAPS_FORWARD_SET = false;\n\tFLAG_MAPS_BACK_WARP_SET = false;\n\t\n}\n\nvoid CThinPlateSpline::setCorrespondences(const std::vector<Point>& pS, const std::vector<Point>& pD)\n{\n\tpSrc = pS;\n\tpDst = pD;\n\n\t// tell the class to recompute the coefficients if neccesarry \n\tFLAG_COEFFS_BACK_WARP_SET = false;\n\tFLAG_COEFFS_FORWARD_WARP_SET = false;\n\tFLAG_MAPS_FORWARD_SET = false;\n\tFLAG_MAPS_BACK_WARP_SET = false;\n}\n\ndouble CThinPlateSpline::fktU(const Point& p1, const Point& p2) \n{\n\tdouble r = pow(((double)p1.x - (double)p2.x), 2) + pow(((double)p1.y - (double)p2.y), 2);\n\n\tif (r == 0)\n\t\treturn 0.0;\n\telse \n\t{\n\t\tr = sqrt(r); // vector length\n\t\tdouble r2 = pow(r, 2);\n\n\t\treturn (r2 * log(r2));\n\t}\n}\n\nvoid CThinPlateSpline::computeSplineCoeffs(std::vector<Point>& iPIn, std::vector<Point>& iiPIn, float lambda,const TPS_INTERPOLATION tpsInter)\n{\n\n\tstd::vector<Point>* iP = NULL;\n\tstd::vector<Point>*\tiiP = NULL;\n\n\tif(tpsInter == FORWARD_WARP)\n\t{\n\t\tiP = &iPIn;\n\t\tiiP = &iiPIn;\n\n\t\t// keep information which coefficients are set\n\t\tFLAG_COEFFS_BACK_WARP_SET = true;\n\t\tFLAG_COEFFS_FORWARD_WARP_SET = false;\n\t}\n\telse if(tpsInter == BACK_WARP)\n\t{\n\t\tiP = &iiPIn;\n\t\tiiP = &iPIn;\n\n\t\t// keep information which coefficients are set\n\t\tFLAG_COEFFS_BACK_WARP_SET = false;\n\t\tFLAG_COEFFS_FORWARD_WARP_SET = true;\n\t}\n\n\t//get number of corresponding points\n\tint dim = 2;\n\tint n = iP->size();\n\n\t//Initialize mathematical datastructures\n\tMat_<float> V(dim,n+dim+1,0.0);\n\tMat_<float> P(n,dim+1,1.0);\n\tMat_<float> K = (K.eye(n,n)*lambda);\n\tMat_<float> L(n+dim+1,n+dim+1,0.0);\n\n\t// fill up K und P matrix\n\tstd::vector<Point>::iterator itY;\n\tstd::vector<Point>::iterator itX;\n\n\tint y = 0;\n\tfor (itY = iP->begin(); itY != iP->end(); ++itY, y++) {\n\t\tint x = 0;\n\t\tfor (itX = iP->begin(); itX != iP->end(); ++itX, x++) {\n\t\t\tif (x != y) {\n\t\t\t\tK(y, x) = (float)fktU(*itY, *itX);\n\t\t\t}\n\t\t}\n\t\tP(y,1) = (float)itY->y;\n\t\tP(y,2) = (float)itY->x;\n\t}\n\n\tMat Pt;\n\ttranspose(P,Pt);\n\n\t// insert K into L\n\tRect range = Rect(0, 0, n, n);\n\tMat Lr(L,range);\n\tK.copyTo(Lr);\n\n\n\t// insert P into L\n\trange = Rect(n, 0, dim + 1, n);\n\tLr = Mat(L,range);\n\tP.copyTo(Lr);\n\n\t// insert Pt into L\n\trange = Rect(0,n,n,dim+1);\n\tLr = Mat(L,range);\n\tPt.copyTo(Lr);\n\n\t// fill V array\n\tstd::vector<Point>::iterator it;\n\tint u = 0;\n\n\tfor(it = iiP->begin(); it != iiP->end(); ++it)\n\t{\n\t\tV(0,u) = (float)it->y;\n\t\tV(1,u) = (float)it->x;\n\t\tu++;\n\t}\n\n\t// transpose V\n\tMat Vt;\n\ttranspose(V,Vt);\n\n\tcMatrix = Mat_<float>(n+dim+1,dim,0.0);\n\n\t// invert L\n\tMat invL;\n\tinvert(L,invL,DECOMP_LU);\n\n\t//multiply(invL,Vt,cMatrix);\n\tcMatrix = invL * Vt;\n\n\t//compensate for rounding errors\n\tfor(int row = 0; row < cMatrix.rows; row++)\n\t{\n\t\tfor(int col = 0; col < cMatrix.cols; col++)\n\t\t{\n\t\t\tdouble v = cMatrix(row,col);\n\t\t\tif(v > (-1.0e-006) && v < (1.0e-006) )\n\t\t\t{\n\t\t\t\tcMatrix(row,col) = 0.0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nPoint CThinPlateSpline::interpolate_forward_(const Point& p)\n{\n\tPoint2f interP;\n\tstd::vector<Point>* pList = &pSrc;\n\n\tint k1 = cMatrix.rows - 3;\n\tint kx = cMatrix.rows - 2;\n\tint ky = cMatrix.rows - 1;\n\n\tdouble a1 = 0, ax = 0, ay = 0, cTmp = 0, uTmp = 0, tmp_i = 0, tmp_ii = 0;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\ta1 = cMatrix(k1,i);\n\t\tax = cMatrix(kx,i);\n\t\tay = cMatrix(ky,i);\n\n\t\ttmp_i = a1 + ax * p.y + ay * p.x;\n\t\ttmp_ii = 0;\n\n\t\tfor (int j = 0; j < (int)pSrc.size(); j++) {\n\t\t\tcTmp = cMatrix(j,i);\n\t\t\tuTmp = fktU( (*pList)[j], p);\n\n\t\t\ttmp_ii = tmp_ii + (cTmp * uTmp);\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tinterP.y = (float)(tmp_i + tmp_ii);\n\t\t}\n\t\tif (i == 1) {\n\t\t\tinterP.x = (float)(tmp_i + tmp_ii);\n\t\t}\n\t}\n\n\treturn interP;\n}\nPoint CThinPlateSpline::interpolate_back_(const Point& p)\n{\n\tPoint2f interP;\n\tstd::vector<Point>* pList = &pDst;\n\n\tint k1 = cMatrix.rows - 3;\n\tint kx = cMatrix.rows - 2;\n\tint ky = cMatrix.rows - 1;\n\n\tdouble a1 = 0, ax = 0, ay = 0, cTmp = 0, uTmp = 0, tmp_i = 0, tmp_ii = 0;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\ta1 = cMatrix(k1,i);\n\t\tax = cMatrix(kx,i);\n\t\tay = cMatrix(ky,i);\n\n\t\ttmp_i = a1 + ax * p.y + ay * p.x;\n\t\ttmp_ii = 0;\n\n\t\tfor (int j = 0; j < (int)pSrc.size(); j++) {\n\t\t\tcTmp = cMatrix(j,i);\n\t\t\tuTmp = fktU( (*pList)[j], p);\n\n\t\t\ttmp_ii = tmp_ii + (cTmp * uTmp);\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tinterP.y = (float)(tmp_i + tmp_ii);\n\t\t}\n\t\tif (i == 1) {\n\t\t\tinterP.x = (float)(tmp_i + tmp_ii);\n\t\t}\n\t}\n\n\treturn interP;\n}\n\nPoint CThinPlateSpline::interpolate(const Point& p, const TPS_INTERPOLATION tpsInter)\n{\n\tif(tpsInter == BACK_WARP)\n\t{\n\t\treturn interpolate_back_(p);\n\t}\n\telse if(tpsInter == FORWARD_WARP)\n\t{\n\t\treturn interpolate_forward_(p);\n\t}\n\telse\n\t{\n\t\treturn interpolate_back_(p);\n\t}\n\t\n}\n\nvoid CThinPlateSpline::warpImage(const Mat& src, Mat& dst, float lambda, const int interpolation,const TPS_INTERPOLATION tpsInter)\n{\n\tSize size = src.size();\n\tdst = Mat(size,src.type());\n\n\t// only compute the coefficients new if they weren't already computed\n\t// or there had been changes to the points\n\tif(tpsInter == BACK_WARP && !FLAG_COEFFS_BACK_WARP_SET)\n\t{\n\t\tcomputeSplineCoeffs(pSrc,pDst,lambda,tpsInter);\n\t}\n\telse if(tpsInter == FORWARD_WARP && !FLAG_COEFFS_FORWARD_WARP_SET)\n\t{\n\t\tcomputeSplineCoeffs(pSrc,pDst,lambda,tpsInter);\n\t}\n\t\n\tcomputeMaps(size,mapx,mapy);\n\n\tremap(src,dst,mapx,mapy,interpolation);\n}\n\nvoid CThinPlateSpline::getMaps(Mat& mx, Mat& my)\n{\n\tmx = mapx;\n\tmy = mapy;\n}\n\nvoid CThinPlateSpline::computeMaps(const Size& dstSize, Mat_<float>& mx, Mat_<float>& my,const TPS_INTERPOLATION tpsInter)\n{\n\tmx = Mat_<float>(dstSize);\n\tmy = Mat_<float>(dstSize);\n\n\tPoint p(0, 0);\n\tPoint_<float> intP(0, 0);\n\t\n\tfor (int row = 0; row < dstSize.height; row++) {\n\t\tfor (int col = 0; col < dstSize.width; col++) {\n\t\t\tp = Point(col, row);\n\t\t\tintP = interpolate(p,tpsInter);\n\t\t\tmx(row, col) = intP.x;\n\t\t\tmy(row, col) = intP.y;\n\t\t}\n\t}\n\n\tif(tpsInter == BACK_WARP)\n\t{\t\n\t\tFLAG_MAPS_BACK_WARP_SET = true;\n\t\tFLAG_MAPS_FORWARD_SET = false;\n\t}\n\telse if(tpsInter == FORWARD_WARP)\n\t{\n\t\tFLAG_MAPS_BACK_WARP_SET = false;\n\t\tFLAG_MAPS_FORWARD_SET = true;\n\t}\n}\n\n",
    "created" : 1476130071667.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2288306703",
    "id" : "B1EDC6EC",
    "lastKnownWriteTime" : 1462749022,
    "last_content_update" : 1462749022,
    "path" : "~/GitHub/fisseq/src/CThinPlateSpline.cpp",
    "project_path" : "src/CThinPlateSpline.cpp",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}