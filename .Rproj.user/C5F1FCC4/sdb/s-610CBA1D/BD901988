{
    "collab_server" : "",
    "contents" : "//============================================================================\n// Name        : 1D/2D Wavelet Transform\n// Author      : Rafat Hussain\n// Version     :\n// Copyright   : GNU GPL License\n// Description : Wavelet Library\n//============================================================================\n/*Copyright (C) 2011 Rafat Hussain\n\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 or any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n *You should have received a copy of the GNU General Public License\n *along with this program; if not, write to the Free Software\n *Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n*/\n\n#include <iostream>\n#include <fstream>\n#include <complex>\n#include \"wavelet2d.h\"\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <fftw3.h>\nusing namespace std;\n\nextern \"C\" int _get_output_format( void ){ return 0; }\nfftw_plan plan_forward_inp,plan_forward_filt, plan_backward;\nstatic unsigned int transient_size_of_fft = 0;\n\n\n\nvoid* per_ext2d(vector<vector<double> > &signal,vector<vector<double> > &temp2, int a) {\n\n        unsigned int rows = signal.size();\n                unsigned int cols = signal[0].size();\n                int cols2;\n                if ((cols % 2) != 0) {\n                    cols2 = cols + 1;\n                } else {\n                    cols2 = cols;\n                }\n                vector<vector<double> > temp_vec(rows ,vector<double>(cols2 + 2* a));\n        //\tvector<vector<double> > temp2(rows + 2 * a ,vector<double>(cols + 2* a));\n\n                for (unsigned int i=0; i < rows; i++) {\n                        vector<double> sig;\n                        for (unsigned int j=0; j< cols; j++) {\n                                double temp = signal[i][j];\n                                sig.push_back(temp);\n                        }\n                        per_ext(sig,a);\n                        for (unsigned int j=0; j< sig.size(); j++) {\n                  temp_vec[i][j] = sig[j];\n                        }\n                }\n                for (unsigned int j=0; j < temp_vec[0].size(); j++) {\n                        vector<double> sig;\n                        for (unsigned int i=0; i< rows; i++) {\n                                double temp = temp_vec[i][j];\n                                sig.push_back(temp);\n                        }\n                        per_ext(sig,a);\n                        for (unsigned int i=0; i< sig.size(); i++) {\n                  temp2[i][j] = sig[i];\n                        }\n                }\n\n\n        return 0;\n}\n\nvoid* swt_2d(vector<vector<double> > &sig,int J, string nm, vector<double> &swt_output) {\n    int m_size = sig.size(); // No. of rows\n    int n_size = sig[0].size(); //No. of columns\n\n\n    vector<vector<double> > sig2 =sig;\n    int rows_n =m_size;\n    int cols_n =n_size;\n    vector<double> lp1,hp1,lp2,hp2;\n    filtcoef(nm,lp1,hp1,lp2,hp2);\n\n    for (int iter =0; iter < J; iter++) {\n    int U = (int) pow(2.0,(double)iter);\n\n    vector<double> low_pass, high_pass;\n    if(iter > 0) {\n        upsamp(lp1,U,low_pass);\n        upsamp(hp1,U,high_pass);\n    } else {\n        low_pass = lp1;\n        high_pass = hp1;\n    }\n\n    int lf = low_pass.size();\n\n    if ((sig.size() % 2) == 0 ) {\n        rows_n = sig.size();\n    } else {\n        rows_n = sig.size() + 1;\n    }\n\n    if ((sig[0].size() % 2) == 0 ) {\n        cols_n = sig[0].size();\n    } else {\n        cols_n = sig[0].size() + 1;\n    }\n\n    vector<vector<double> > signal(rows_n + lf,vector<double>(cols_n+lf));\n    //    per_ext2d(sig,signal,lf/2); Edit per_ext if you want to use per_ext2d. Remove\n    // the even indexing.\n\n    symm_ext2d(sig,signal,lf/2);\n    int len_x = signal.size();\n    int len_y = signal[0].size();\n    vector<vector<double> > sigL(rows_n + lf,vector<double>(cols_n));\n    vector<vector<double> > sigH(rows_n + lf,vector<double>(cols_n));\n    vector<vector<double> > cA(rows_n,vector<double>(cols_n));\n    vector<vector<double> > cH(rows_n,vector<double>(cols_n));\n    vector<vector<double> > cV(rows_n,vector<double>(cols_n));\n    vector<vector<double> > cD(rows_n,vector<double>(cols_n));\n\n    for (int i=0; i < len_x; i++) {\n        vector<double> temp_row;\n        for (int j=0; j < len_y; j++) {\n                double temp = signal[i][j];\n                temp_row.push_back(temp);\n\n        }\n\n        // ------------------Low Pass Branch--------------------------\n\n                vector<double> oup;\n                convfftm(temp_row,low_pass,oup);\n        oup.erase(oup.begin(), oup.begin()+lf);\n                oup.erase(oup.begin()+cols_n,oup.end());\n\n        // ------------------High Pass Branch--------------------------\n\n                vector<double> oup2;\n                convfftm(temp_row,high_pass,oup2);\n        oup2.erase(oup2.begin(), oup2.begin()+lf);\n                oup2.erase(oup2.begin()+cols_n,oup2.end());\n\n                temp_row.clear();\n\n        for (unsigned int j=0; j < oup.size() ; j++) {\n                sigL[i][j] = oup[j];\n            sigH[i][j] = oup2[j];\n        }\n\n    }\n\n    for (int j=0; j < cols_n; j++) {\n        vector<double> temp_row;\n        for (int i=0; i < len_x; i++){\n                double temp = sigL[i][j];\n                temp_row.push_back(temp);\n        }\n\n        // ------------------Low Pass Branch--------------------------\n\n\n                vector<double> oup;\n                convfftm(temp_row,low_pass,oup);\n                oup.erase(oup.begin(), oup.begin()+lf);\n                oup.erase(oup.begin()+rows_n,oup.end());\n\n                // ------------------High Pass Branch--------------------------\n\n                vector<double> oup2;\n                convfftm(temp_row,high_pass,oup2);\n            oup2.erase(oup2.begin(), oup2.begin()+lf);\n                oup2.erase(oup2.begin()+rows_n,oup2.end());\n\n                temp_row.clear();\n\n\n                for (unsigned int i=0; i < oup.size() ; i++) {\n                        cA[i][j] = oup[i];\n                }\n\n                for (unsigned int i=0; i < oup2.size() ; i++) {\n                cH[i][j] = oup2[i];\n                }\n\n\n    }\n\n    for (int j=0; j < cols_n; j++) {\n                vector<double> temp_row;\n                for (int i=0; i < len_x; i++){\n                        double temp = sigH[i][j];\n                        temp_row.push_back(temp);\n                }\n\n                // ------------------Low Pass Branch--------------------------\n\n\n                        vector<double> oup;\n                        convfftm(temp_row,low_pass,oup);\n                oup.erase(oup.begin(), oup.begin()+lf);\n                        oup.erase(oup.begin()+rows_n,oup.end());\n\n                // ------------------High Pass Branch--------------------------\n\n                        vector<double> oup2;\n                        convfftm(temp_row,high_pass,oup2);\n                oup2.erase(oup2.begin(), oup2.begin()+lf);\n                        oup2.erase(oup2.begin()+rows_n,oup2.end());\n\n                        temp_row.clear();\n\n\n                for (unsigned int i=0; i < oup.size() ; i++) {\n                        cV[i][j] = oup[i];\n                }\n\n                for (unsigned int i=0; i < oup2.size() ; i++) {\n                    cD[i][j] = oup2[i];\n                }\n\n\n        }\n\n       sig = cA;\n       vector<double> temp_sig2;\n\n       if (iter == J-1) {\n                                for(int i =0; i < rows_n; i++){\n                                        for (int j =0; j < cols_n; j++){\n                                        double temp=cA[i][j];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n                           }\n                                for(int i =0; i < rows_n; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                        double temp =cH[i][j - cols_n];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j =0; j < cols_n; j++){\n                                        double temp=cV[i - rows_n][j];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                        double temp =cD[i- rows_n][j - cols_n];\n                                         temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                swt_output.insert(swt_output.begin(),temp_sig2.begin(),temp_sig2.end());\n\n\n\n    }\n\n\n        return 0;\n}\n\n\nvoid* per_ext(vector<double> &sig, int a) {\n        unsigned int len;\n    len = sig.size();\n    if ((len % 2) != 0 ) {\n        double temp = sig[len-1];\n        sig.push_back(temp);\n        len = sig.size();\n    }\n\n        for (int i=0; i < a; i++) {\n    double temp1 = sig[2 *i];\n    double temp2 = sig[len-1];\n    sig.insert(sig.begin(), temp2);\n    sig.insert(sig.end(), temp1);\n\n        }\n\n        return 0;\n\n}\n\n\nvoid* iswt(vector<double> &swtop,int J, string nm, vector<double> &iswt_output) {\n         int N = swtop.size() / (J + 1);\n\n     vector<double> lpd,hpd,lpr,hpr;\n         filtcoef(nm,lpd,hpd,lpr,hpr);\n\n         vector<double> appx_sig;\n\n     vector<double> low_pass = lpr;\n     vector<double> high_pass = hpr;\n     int lf = low_pass.size();\n\n     for (int iter = 0; iter < J; iter++) {\n     vector<double> det_sig;\n         if (iter ==0) {\n         for (int i = 0; i < N; i++) {\n                 double temp=swtop[i];\n                 appx_sig.push_back(temp);\n                 double temp1=swtop[(iter + 1) * N + i];\n                 det_sig.push_back(temp1);\n         }\n         } else {\n                 for (int i = 0; i < N; i++) {\n                 double temp1=swtop[(iter + 1) * N + i];\n                 det_sig.push_back(temp1);\n\n         }\n         }\n\n\n           int value =(int) pow(2.0,double(J -1 -iter));\n           iswt_output.assign(N,0.0);\n\n          for (int count = 0; count < value; count++) {\n        vector<double> appx1, det1;\n        for (int index = count; index < N; index+=value){\n                double temp = appx_sig[index];\n                appx1.push_back(temp);\n                double temp1 = det_sig[index];\n                det1.push_back(temp1);\n\n        }\n        unsigned int len = appx1.size();\n\n        // Shift = 0\n\n         vector<double> appx2, det2;\n\n         for (unsigned int index_shift =0; index_shift < len; index_shift+=2) {\n                double temp = appx1[index_shift];\n                appx2.push_back(temp);\n                double temp1 = det1[index_shift];\n                det2.push_back(temp1);\n         }\n\n         int U = 2; // Upsampling Factor\n\n         vector<double> cL0,cH0;\n         upsamp(appx2,U,cL0);\n         upsamp(det2,U,cH0);\n         per_ext(cL0,lf/2);\n         per_ext(cH0,lf/2);\n\n         vector<double> oup00L, oup00H, oup00;\n         convfft(cL0,low_pass,oup00L);\n         convfft(cH0,high_pass,oup00H);\n\n         oup00L.erase(oup00L.begin(),oup00L.begin()+lf - 1);\n                 oup00L.erase(oup00L.begin()+len,oup00L.end());\n         oup00H.erase(oup00H.begin(),oup00H.begin()+lf - 1);\n                 oup00H.erase(oup00H.begin()+len,oup00H.end());\n\n                 vecsum(oup00L,oup00H,oup00);\n\n                 // Shift = 1\n\n                 vector<double> appx3, det3;\n\n                         for (unsigned int index_shift =1; index_shift < len; index_shift+=2) {\n                                double temp = appx1[index_shift];\n                                appx3.push_back(temp);\n                                double temp1 = det1[index_shift];\n                                det3.push_back(temp1);\n                         }\n\n\n                         vector<double> cL1,cH1;\n                         upsamp(appx3,U,cL1);\n                         upsamp(det3,U,cH1);\n                         per_ext(cL1,lf/2);\n                         per_ext(cH1,lf/2);\n\n                         vector<double> oup01L, oup01H, oup01;\n                         convfft(cL1,low_pass,oup01L);\n                         convfft(cH1,high_pass,oup01H);\n\n                         oup01L.erase(oup01L.begin(), oup01L.begin()+lf - 1);\n                                 oup01L.erase(oup01L.begin()+len,oup01L.end());\n                         oup01H.erase(oup01H.begin(), oup01H.begin()+lf - 1);\n                                 oup01H.erase(oup01H.begin()+len,oup01H.end());\n\n                                 vecsum(oup01L,oup01H,oup01);\n                                 circshift(oup01,-1);\n\n         //   Continue\n              int index2 = 0;\n                        for (int index = count; index < N; index+=value){\n                                        double temp = oup00[index2]+oup01[index2];\n                                        iswt_output.at(index) = temp/2;\n                                        index2++;\n\n                                }\n\n\n     }\n                appx_sig = iswt_output;\n\n\n     }\n        return 0;\n}\n\nvoid* swt(vector<double> &signal1, int J, string nm, vector<double> &swt_output, int &length) {\n        vector<double> lpd, hpd, lpr, hpr;\n        vector<double> sig = signal1;\n\n            int N = sig.size();\n            length = N;\n\n           filtcoef(nm,lpd,hpd,lpr,hpr);\n\n        for (int iter = 0; iter < J; iter++) {\n                vector<double> low_pass;\n                vector<double> high_pass;\n              if ( iter > 0){\n\n                  int M = (int) pow(2.0,iter);\n                  upsamp(lpd,M,low_pass);\n                  upsamp(hpd,M,high_pass);\n\n\n              } else {\n                  low_pass = lpd;\n                  high_pass = hpd;\n              }\n\n              unsigned int len_filt = low_pass.size();\n               per_ext(sig,len_filt/2);\n\n                        vector<double> cA;\n                        convfft(sig,low_pass,cA);\n                        vector<double> cD;\n                        convfft(sig,high_pass,cD);\n                        // Resize cA and cD\n                cA.erase(cA.begin(), cA.begin()+len_filt);\n                        cA.erase(cA.begin()+N,cA.end());\n                cD.erase(cD.begin(), cD.begin()+len_filt);\n                        cD.erase(cD.begin()+N,cD.end());\n                        // Reset signal value;\n\n                        sig = cA;\n\n             if (iter == J - 1 ) {\n             swt_output.insert(swt_output.begin(),cD.begin(),cD.end());\n             swt_output.insert(swt_output.begin(),cA.begin(),cA.end());\n             } else {\n                 swt_output.insert(swt_output.begin(),cD.begin(),cD.end());\n             }\n\n                }\n\n  return 0;\n}\n\nvoid* dwt_output_dim_sym(vector<int> &length,vector<int> &length2, int J) {\n        unsigned int sz=length.size();\n        int rows = length[sz-2];\n        int cols = length[sz-1];\n    for (int i =0; i < J; i++) {\n     rows =(int) ceil((double) rows/ 2.0);\n     cols =(int) ceil((double) cols/ 2.0);\n     }\n    for (int i =0; i < J + 1; i++) {\n        length2.push_back(rows);\n        length2.push_back(cols);\n        rows = rows * 2;\n        cols = cols*2;\n    }\n        return 0;\n}\n\nvoid* dwt_output_dim2(vector<int> &length, vector<int> &length2, int J) {\n\n   int row = length[0];\n   int col = length[1];\n\n   for (int i=0; i < J + 1; i++) {\n\n       length2.push_back(row);\n       length2.push_back(col);\n       row = row * 2;\n       col = col * 2;\n\n\n   }\n\n\n    return 0;\n}\n\nvoid* dispDWT(vector<double> &output,vector<vector<double> > &dwtdisp, vector<int> &length , vector<int> &length2, int J) {\n          int sum = 0;\n\n\n        for (int iter =0; iter < J; iter++) {\n                int d_rows=length[2*iter]-length2[2*iter];\n                int d_cols=length[2*iter+1]-length2[2*iter + 1];\n\n\n                int rows_n =length[2 * iter];\n                int cols_n = length[2 * iter + 1];\n                vector<vector<double> >  dwt_output(2 * rows_n, vector<double>(2 * cols_n));\n        if (iter == 0) {\n                for(int i =0; i < rows_n; i++){\n                        for (int j =0; j < cols_n; j++){\n                                dwt_output[i][j]=output[i*cols_n + j];\n                        }\n                }\n\n                for(int i =0; i < rows_n; i++){\n                        for (int j = cols_n; j < cols_n * 2; j++){\n                                dwt_output[i][j]= output[rows_n * cols_n + i * cols_n + (j - cols_n)];\n                        }\n                }\n\n                for(int i = rows_n; i < rows_n * 2; i++){\n                        for (int j =0; j < cols_n; j++){\n                                dwt_output[i][j]=output[2 * rows_n * cols_n+ (i - rows_n) * cols_n + j];\n                        }\n                }\n\n\n                for(int i = rows_n; i < rows_n * 2; i++){\n                        for (int j = cols_n; j < cols_n * 2; j++){\n                                dwt_output[i][j]=output[3 * rows_n * cols_n+ (i -rows_n) * cols_n + (j -cols_n)];\n                        }\n                }\n        } else {\n                for(int i =0; i < rows_n; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                                dwt_output[i][j]= output[sum + i * cols_n + (j - cols_n)];\n                                        }\n                                }\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j =0; j < cols_n; j++){\n                                                dwt_output[i][j]=output[sum + rows_n * cols_n+ (i - rows_n) * cols_n + j];\n                                        }\n                                }\n\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                                dwt_output[i][j]=output[sum + 2 * rows_n * cols_n+ (i -rows_n) * cols_n + (j -cols_n)];\n                                        }\n                                }\n\n        }\n\n                int rows_x = length2[2*iter];\n        int cols_x =length2[2*iter +1];\n\n        int d_cols2 = (int) ceil( (double) (d_cols - 1) / 2.0);\n        int d_rows2 = (int) ceil( (double) (d_rows - 1) / 2.0);\n        if (iter ==0) {\n        for(int i =0; i < rows_x; i++){\n                                for (int j =0; j < cols_x; j++){\n                                        if (i + d_rows -1 < 0){\n                                                dwtdisp[i][j]=0;\n                                        }\n                                        else if (j + d_cols -1 < 0){\n                                                dwtdisp[i][j]=0;\n                                                } else {\n                                        dwtdisp[i][j]=dwt_output[i+d_rows -1][j+d_cols -1];\n                                                }\n                                }\n                        }\n        }\n                        for(int i =0; i < rows_x; i++){\n                                for (int j = cols_x; j < cols_x * 2; j++){\n                                        if (i + d_rows2 < 0){\n                                                dwtdisp[i][j]=0;\n                                        }\n                                        else if (j + 2* (d_cols -1) +1 > (signed) dwt_output[0].size() - 1){\n                                                dwtdisp[i][j]=0;\n                                                                                                                        } else {\n                                        dwtdisp[i][j]= dwt_output[i+d_rows2 ][j + 2* (d_cols -1)+1 ];\n                                                                                                                        }\n                                }\n                        }\n\n                        for(int i = rows_x; i < rows_x * 2; i++){\n                                for (int j =0; j < cols_x; j++){\n                                        if (i + 2* (d_rows -1) + 1 > (signed) dwt_output.size() - 1){\n                                                dwtdisp[i][j]=0;\n                                        }\n                                        else if (j + d_cols2 < 0){\n                                                dwtdisp[i][j]=0;\n                                            } else {\n\n                                        dwtdisp[i][j]=dwt_output[i+2 * (d_rows - 1) + 1 ][j+d_cols2 ];\n                                            }\n                                }\n                        }\n\n                        for(int i = rows_x; i < rows_x * 2; i++){\n                                for (int j = cols_x; j < cols_x * 2; j++){\n\n                                        if (i +  (d_rows -1) + 1 + d_rows2 > (signed) dwt_output.size() - 1){\n                                                dwtdisp[i][j]=0;\n                                                                                }\n                                        else if (j + (d_cols -1) + 1 + d_cols2  > (signed) dwt_output[0].size() - 1){\n                                                dwtdisp[i][j]=0;\n                                                                                        } else {\n                                        dwtdisp[i][j]=dwt_output[i +  (d_rows -1) + 1 + d_rows2 ][j + (d_cols -1) + 1 + d_cols2 ];\n                                                                                        }\n                                }\n                        }\n                        if (iter == 0) {\n                                sum+= 4*rows_n*cols_n;\n                        } else {\n                                sum+= 3*rows_n * cols_n;\n                        }\n\n        }\n\n        return 0;\n\n}\n\nvoid symm_ext2d(vector<vector<double> > &signal,vector<vector<double> > &temp2, int a) {\n        unsigned int rows = signal.size();\n        unsigned int cols = signal[0].size();\n        vector<vector<double> > temp_vec(rows ,vector<double>(cols + 2* a));\n//\tvector<vector<double> > temp2(rows + 2 * a ,vector<double>(cols + 2* a));\n\n        for (unsigned int i=0; i < rows; i++) {\n                vector<double> sig;\n                for (unsigned int j=0; j< cols; j++) {\n                        double temp = signal[i][j];\n                        sig.push_back(temp);\n                }\n                symm_ext(sig,a);\n                for (unsigned int j=0; j< sig.size(); j++) {\n          temp_vec[i][j] = sig[j];\n                }\n        }\n        for (unsigned int j=0; j < temp_vec[0].size(); j++) {\n                vector<double> sig;\n                for (unsigned int i=0; i< rows; i++) {\n                        double temp = temp_vec[i][j];\n                        sig.push_back(temp);\n                }\n                symm_ext(sig,a);\n                for (unsigned int i=0; i< sig.size(); i++) {\n          temp2[i][j] = sig[i];\n                }\n        }\n\n}\n\nvoid* circshift2d(vector<vector<double> > &signal, int x, int y) {\n        unsigned int rows = signal.size();\n        unsigned int cols = signal[0].size();\n        vector<vector<double> > temp_vec(rows,vector<double>(cols));\n\n        for (unsigned int i=0; i < rows; i++) {\n                vector<double> sig;\n                for (unsigned int j=0; j< cols; j++) {\n                        double temp = signal[i][j];\n                        sig.push_back(temp);\n                }\n                circshift(sig,x);\n                for (unsigned int j=0; j< cols; j++) {\n          temp_vec[i][j] = sig[j];\n                }\n        }\n\n        for (unsigned int j=0; j < cols; j++) {\n                vector<double> sig;\n                for (unsigned int i=0; i< rows; i++) {\n                        double temp = temp_vec[i][j];\n                        sig.push_back(temp);\n                }\n                circshift(sig,y);\n                for (unsigned int i=0; i< rows; i++) {\n          signal[i][j] = sig[i];\n                }\n        }\n  return 0;\n}\n\nvoid* idwt_2d_sym(vector<double>  &dwtop,vector<double> &flag, string nm,\n                vector<vector<double> > &idwt_output, vector<int> &length){\n    int J =(int) flag[0];\n    int rows =length[0];\n    int cols =length[1];\n\n    int sum_coef =0;\n    vector<double> lp1,hp1,lp2,hp2;\n    filtcoef(nm,lp1,hp1,lp2,hp2);\n    unsigned int lf = lp1.size();\n        vector<vector<double> >  cLL(rows, vector<double>(cols));\n\n\n    for (int iter=0; iter < J; iter++) {\n\n        int rows_n = length[2*iter];\n        int cols_n = length[2*iter + 1];\n\n        vector<vector<double> >  cLH(rows_n, vector<double>(cols_n));\n        vector<vector<double> >  cHL(rows_n, vector<double>(cols_n));\n        vector<vector<double> >  cHH(rows_n, vector<double>(cols_n));\n\n        for (int i = 0 ; i < rows_n; i++ ){\n                for (int j = 0; j < cols_n; j++){\n                        if (iter == 0) {\n                        cLL[i][j] = dwtop[sum_coef+ i * cols_n + j];\n\n                cLH[i][j] = dwtop[sum_coef+ rows_n * cols_n+ i * cols_n + j];\n\n                cHL[i][j] = dwtop[sum_coef+ 2 * rows_n * cols_n + i * cols_n + j];\n\n                cHH[i][j] = dwtop[sum_coef+ 3* rows_n * cols_n + i * cols_n + j];\n                        } else {\n\n                        cLH[i][j] = dwtop[sum_coef+  i * cols_n + j];\n\n                        cHL[i][j] = dwtop[sum_coef+ rows_n * cols_n + i * cols_n + j];\n\n                    cHH[i][j] = dwtop[sum_coef+ 2* rows_n * cols_n + i * cols_n + j];\n\n                        }\n                }\n        }\n\n\n  //      temp_A = cLL;\n  //  \tidwt2_sym(nm,idwt_output2, cA, cH,cV,cD);\n\n        unsigned int len_x = cLH.size();\n        unsigned int len_y = cLH[0].size();\n\n        // Row Upsampling and Column Filtering at the first LP Stage\n        vector<vector<double> > cL(2 *len_x - lf + 2,vector<double>(len_y ));\n        vector<vector<double> > cH(2 * len_x - lf +2,vector<double>(len_y ));\n\n        if (iter ==0) {\n        for (unsigned int j =0; j < len_y; j++) {\n\n                        vector<double> sigLL,sigLH,oup;\n\n                        for (unsigned int i=0;i <  len_x;i++) {\n\n                                double temp1 = cLL[i][j];\n                                double temp2 = cLH[i][j];\n                                sigLL.push_back(temp1);\n                                sigLH.push_back(temp2);\n                        }\n                        idwt1_sym_m(nm,oup,sigLL,sigLH);\n\n                                for (int i=0;i < (int) oup.size();i++) {\n                                cL[i][j] = oup[i];\n                                }\n\n                }\n        } else{\n                unsigned int rows1 =cLH.size();\n                unsigned int cols1 =cLH[0].size();\n\n                for (unsigned int j =0; j < cols1;j++){\n                        vector<double> temp_L1,temp_L2,oup;\n                        for (unsigned int i =0; i < rows1; i++){\n                                double temp = cLL[i][j];\n                                temp_L1.push_back(temp);\n\n                                double temp2 = cLH[i][j];\n                                temp_L2.push_back(temp2);\n                        }\n                        idwt1_sym_m(nm,oup,temp_L1,temp_L2);\n\n                                for (unsigned int i =0; i < oup.size(); i++){\n                                        cL[i][j]=oup[i];\n                                }\n\n               }\n            }\n\n\n        for (unsigned int j =0; j < len_y; j++) {\n                        vector<double> sigHL,sigHH,oup2;\n                        for (unsigned int i=0;i <  len_x;i++) {\n                                double temp3 = cHL[i][j];\n                                double temp4 = cHH[i][j];\n                                sigHL.push_back(temp3);\n                                sigHH.push_back(temp4);\n                        }\n                        idwt1_sym_m(nm,oup2,sigHL,sigHH);\n\n                                for (int i=0;i < (int) oup2.size();i++) {\n                                cH[i][j] = oup2[i];\n                                }\n\n                }\n\n       vector<vector<double> > signal(2*len_x-lf +2,vector<double>(2 *len_y - lf +2 ));\n        for (unsigned int i =0; i < 2 * len_x - lf +2; i++) {\n                        vector<double> sigL,sigH,oup;\n                        for (unsigned int j=0;j <  len_y;j++) {\n                                double temp5 = cL[i][j];\n                                double temp6 = cH[i][j];\n                                sigL.push_back(temp5);\n                                sigH.push_back(temp6);\n                        }\n                        idwt1_sym_m(nm,oup,sigL,sigH);\n\n                                for (int j=0;j < (int) oup.size();j++) {\n                                signal[i][j] = oup[j];\n                                }\n\n                }\n\n\n        idwt_output = signal;\n\n\n\n       if (iter ==0) {\n           sum_coef+= 4 *rows_n * cols_n;\n       } else {\n           sum_coef+= 3 *rows_n * cols_n;\n       }\n   cLL = signal;\n\n\n    }\n\n\n        return 0;\n}\n\n\nvoid* dwt2_sym(string name,vector<vector<double> > &signal, vector<vector<double> >  &cLL,\n                vector<vector<double> >  &cLH, vector<vector<double> >  &cHL, vector<vector<double> > &cHH){\n//Analysis\n    int rows = signal.size();\n    int cols = signal[0].size();\n    int cols_lp1 = cLL[0].size();\n    int cols_hp1 = cLL[0].size();\n    vector<double> lp1,hp1,lp2,hp2;\n    filtcoef(name, lp1,hp1,lp2,hp2);\n    vector<vector<double> > lp_dn1(rows, vector<double>( cols_lp1));\n    vector<vector<double> > hp_dn1(rows, vector<double>( cols_hp1));\n\n    // Implementing row filtering and column downsampling in each branch.\n    for (int i =0; i < rows; i++) {\n                vector<double> temp_row,oup_lp,oup_hp;\n                for (int j=0;j <  cols;j++) {\n                        double temp = signal[i][j];\n                        temp_row.push_back(temp);\n                }\n                dwt1_sym_m(name,temp_row,oup_lp,oup_hp);\n\n                        for (int j=0;j < (int) oup_lp.size();j++) {\n                        lp_dn1[i][j] = oup_lp[j];\n                        hp_dn1[i][j] = oup_hp[j];\n\n                        }\n\n        }\n\n\n    cols =cols_lp1;\n    // Implementing column filtering and row downsampling in Low Pass branch.\n\n    for (int j =0; j < cols; j++) {\n                vector<double> temp_row3,oup_lp,oup_hp;\n                for (int i=0;i <  rows;i++) {\n                        double temp = lp_dn1[i][j];\n                        temp_row3.push_back(temp);\n                }\n                dwt1_sym_m(name,temp_row3,oup_lp,oup_hp);\n\n                        for (int i=0;i < (int) oup_lp.size();i++) {\n                        cLL[i][j] = oup_lp[i];\n                        cLH[i][j] = oup_hp[i];\n\n                        }\n\n\n        }\n\n\n\n    // Implementing column filtering and row downsampling in High Pass branch.\n\n    for (int j =0; j < cols; j++) {\n                vector<double> temp_row5,oup_lp,oup_hp;\n                for (int i=0;i <  rows;i++) {\n                        double temp = hp_dn1[i][j];\n                        temp_row5.push_back(temp);\n                }\n                dwt1_sym_m(name,temp_row5,oup_lp,oup_hp);\n\n                        for (int i=0;i < (int) oup_lp.size();i++) {\n                        cHL[i][j] = oup_lp[i];\n                        cHH[i][j] = oup_hp[i];\n\n                        }\n\n\n        }\n    return 0;\n}\n\n\nvoid* dwt_2d_sym(vector<vector<double> > &origsig, int J, string nm, vector<double> &dwt_output\n                , vector<double> &flag , vector<int> &length) {\n// flag will contain\n\n   vector<vector<double> >  sig = origsig;\n        int rows_n = sig.size(); // No. of rows\n    int cols_n = sig[0].size(); //No. of columns\n    vector<vector<double> > original_copy(rows_n,vector<double>(cols_n));\n\n        original_copy = sig;\n        int Max_Iter;\n                    Max_Iter = min((int) ceil(log( double(sig.size()))/log (2.0)),(int) ceil(log( double(sig[0].size()))/log (2.0)));\n                    if ( Max_Iter < J) {\n                        cout << J << \" Iterations are not possible with signals of this dimension \"  << endl;\n                        exit(1);\n                    }\n                    vector<double> lp1,hp1,lp2,hp2;\n\n                    flag.push_back(double(J));\n\n\n                     length.insert(length.begin(),cols_n);\n                     length.insert(length.begin(),rows_n);\n\n\n   // Flag Values\n                     /*\n                        double temp = (double) (sig2.size() - sig.size()); // Number of zeropad rows\n                        flag.push_back(temp);\n                        double temp2 = (double) (sig2[0].size() - sig[0].size());// Number of zpad cols\n                        flag.push_back(temp2);\n                        flag.push_back((double) J); // Number of Iterations\n                        */\n                int sum_coef = 0;\n                 for (int iter = 0; iter < J; iter++) {\n                 filtcoef(nm,lp1,hp1,lp2,hp2);\n                 unsigned int lf = lp1.size();\n\n                        rows_n =(int) floor((double)(rows_n + lf -1)/2);\n                        cols_n =(int) floor((double) (cols_n + lf -1)/2);\n                        length.insert(length.begin(),cols_n);\n                        length.insert(length.begin(),rows_n);\n\n                                vector<vector<double> >  cA(rows_n, vector<double>(cols_n));\n                                vector<vector<double> >  cH(rows_n, vector<double>(cols_n));\n                                vector<vector<double> >  cV(rows_n, vector<double>(cols_n));\n                                vector<vector<double> >  cD(rows_n, vector<double>(cols_n));\n\n                                if (iter == 0) {\n                                dwt2_sym(nm,original_copy,cA,cH,cV,cD);\n                                } else {\n                                        dwt2_sym(nm,original_copy,cA,cH,cV,cD);\n\n                                }\n                                vector<double>   temp_sig2;\n\n                    original_copy = cA;\n                    if (iter == J-1) {\n                                for(int i =0; i < rows_n; i++){\n                                        for (int j =0; j < cols_n; j++){\n                                        double temp=cA[i][j];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n                    }\n                                for(int i =0; i < rows_n; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                        double temp =cH[i][j - cols_n];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j =0; j < cols_n; j++){\n                                        double temp=cV[i - rows_n][j];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                        double temp =cD[i- rows_n][j - cols_n];\n                                         temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                dwt_output.insert(dwt_output.begin(),temp_sig2.begin(),temp_sig2.end());\n                                         sum_coef += 4 * rows_n * cols_n;\n\n\n\n                        }\n/*\n                        ofstream dwt2out(\"dwt2out.dat\");\n                        for (unsigned int i= 0; i < dwt_output.size(); i++){\n                   dwt2out << dwt_output[i] <<endl;\n                        }\n                        */\n\n        return 0;\n\n}\n\n\nvoid* idwt1_sym(string wname, vector<double> &X, vector<double> &app, vector<double> &detail) {\n\n        // Not Tested. Use dwt_sym and idwt_sym for any and all computations\n        vector<double> dwtop;\n        vector<double> flag;\n        vector<double> idwt_output;\n    vector<int> length;\n    length[0] = app.size();\n    length[1] = detail.size();\n    dwtop = app;\n    dwtop.insert(dwtop.end(),detail.begin(),detail.end());\n    flag.push_back(1);\n    flag.push_back(0);\n    idwt_sym(dwtop,flag,wname,idwt_output,length);\n    X = idwt_output;\n\n   return 0;\n}\n\nvoid* idwt1_sym_m(string wname, vector<double> &idwt_output, vector<double> &app, vector<double> &detail) {\n\n    int U = 2; // Upsampling Factor\n    vector<double> lpd1,hpd1, lpr1, hpr1;\n\n    filtcoef(wname,lpd1,hpd1,lpr1,hpr1);\n     int lf = lpr1.size();\n\n\n            // Operations in the Low Frequency branch of the Synthesis Filter Bank\n            vector<double> X_lp;\n            vector<double> cA_up;\n            upsamp(app, U,cA_up );\n            cA_up.pop_back();\n            convfftm(cA_up, lpr1, X_lp);\n\n\n\n            // Operations in the High Frequency branch of the Synthesis Filter Bank\n\n            vector<double> X_hp;\n            vector<double> cD_up;\n            upsamp(detail, U, cD_up);\n            cD_up.pop_back();\n            convfftm(cD_up, hpr1, X_hp);\n\n\n    vecsum(X_lp,X_hp,idwt_output);\n\n    idwt_output.erase(idwt_output.begin(),idwt_output.begin()+lf-2);\n    idwt_output.erase(idwt_output.end()-(lf - 2),idwt_output.end());\n\n   return 0;\n}\n\n\nvoid* symm_ext(vector<double> &sig, int a) {\n        unsigned int len = sig.size();\n        for (int i =0; i < a; i++) {\n                double temp1= sig[i * 2];\n                double temp2= sig[len - 1];\n                sig.insert(sig.begin(),temp1);\n                sig.insert(sig.end(),temp2);\n        }\n\n        return 0;\n\n}\n\nvoid* idwt_sym(vector<double> &dwtop,vector<double> &flag, string nm,\n                vector<double> &idwt_output, vector<int> &length) {\n\n        int J =(int) flag[1];\n        unsigned int lf;\n\n            vector<double> app;\n            vector<double> detail;\n            unsigned int app_len = length[0];\n            unsigned int det_len = length[1];\n\n        vector<double>::iterator dwt;\n        dwt = dwtop.begin();\n        app.assign(dwt,dwtop.begin()+app_len);\n        detail.assign(dwtop.begin()+app_len, dwtop.begin()+ 2* app_len);\n\n            for (int i = 0; i < J; i++) {\n\n                int U = 2; // Upsampling Factor\n                vector<double> lpd1,hpd1, lpr1, hpr1;\n\n                filtcoef(nm,lpd1,hpd1,lpr1,hpr1);\n                 lf = lpr1.size();\n\n\n                        // Operations in the Low Frequency branch of the Synthesis Filter Bank\n                        vector<double> X_lp;\n                        vector<double> cA_up;\n                        upsamp(app, U,cA_up );\n                        cA_up.pop_back();\n                        convfft(cA_up, lpr1, X_lp);\n\n\n\n                        // Operations in the High Frequency branch of the Synthesis Filter Bank\n\n                        vector<double> X_hp;\n                        vector<double> cD_up;\n                        upsamp(detail, U, cD_up);\n                        cD_up.pop_back();\n                        convfft(cD_up, hpr1, X_hp);\n\n\n                app_len += det_len;\n                vecsum(X_lp,X_hp,idwt_output);\n\n                idwt_output.erase(idwt_output.begin(),idwt_output.begin()+lf-2);\n                idwt_output.erase(idwt_output.end()-(lf - 2),idwt_output.end());\n\n                app.clear();\n                detail.clear();\n                        if ( i < J - 1 ) {\n                                det_len = length[i+2];\n        //        detail.assign(dwtop.begin()+app_len, dwtop.begin()+ det_len);\n\n            for (unsigned int l = 0; l < det_len;l++) {\n                double temp = dwtop[app_len + l];\n                detail.push_back(temp);\n            }\n\n                        }\n            app = idwt_output;\n\n            for (int iter1 = 0; iter1 < (int) (app.size() - det_len);iter1++) {\n                app.pop_back();\n            }\n\n            }\n\n\n            // Remove ZeroPadding\n\n            int zerop =(int) flag[0];\n            idwt_output.erase(idwt_output.end()- zerop,idwt_output.end());\n            return 0;\n}\n\nvoid* dwt1_sym(string wname, vector<double> &signal, vector<double> &cA, vector<double> &cD) {\n\n        vector<double> lp1, hp1, lp2, hp2;\n\n                filtcoef(wname,lp1,hp1,lp2,hp2);\n                int D = 2; // Downsampling Factor is 2\n                int lf = lp1.size();\n                symm_ext(signal,lf-1);\n\n                 vector<double> cA_undec;\n                     //sig value\n                     convfft(signal,lp1,cA_undec);\n                     cA_undec.erase(cA_undec.begin(),cA_undec.begin()+lf);\n                     cA_undec.erase(cA_undec.end()-lf+1,cA_undec.end());\n                     downsamp(cA_undec, D, cA);\n                   //  cA.erase(cA.begin(),cA.begin()+(int) ceil(((double)lf-1.0)/2.0));\n                   //  cA.erase(cA.end()-(int) ceil(((double)lf-1.0)/2.0),cA.end());\n\n\n                     //High Pass Branch Computation\n\n                     vector<double> cD_undec;\n                     convfft(signal,hp1,cD_undec);\n                     cD_undec.erase(cD_undec.begin(),cD_undec.begin()+lf);\n                     cD_undec.erase(cD_undec.end()-lf+1,cD_undec.end());\n                     downsamp(cD_undec,D,cD);\n                  //   cD.erase(cD.begin(),cD.begin()+(int) ceil(((double)lf-1.0)/2.0));\n                  //   cD.erase(cD.end()-(int) ceil(((double)lf-1.0)/2.0),cD.end());\n\n                filtcoef(wname,lp1,hp1,lp2,hp2);\n\n  return 0;\n}\n\nvoid* dwt1_sym_m(string wname, vector<double> &signal, vector<double> &cA, vector<double> &cD) {\n\n        vector<double> lp1, hp1, lp2, hp2;\n\n                filtcoef(wname,lp1,hp1,lp2,hp2);\n                int D = 2; // Downsampling Factor is 2\n                int lf = lp1.size();\n                symm_ext(signal,lf-1);\n\n                 vector<double> cA_undec;\n                     //sig value\n                     convfftm(signal,lp1,cA_undec);\n                     cA_undec.erase(cA_undec.begin(),cA_undec.begin()+lf);\n                     cA_undec.erase(cA_undec.end()-lf+1,cA_undec.end());\n                     downsamp(cA_undec, D, cA);\n                   //  cA.erase(cA.begin(),cA.begin()+(int) ceil(((double)lf-1.0)/2.0));\n                   //  cA.erase(cA.end()-(int) ceil(((double)lf-1.0)/2.0),cA.end());\n\n\n                     //High Pass Branch Computation\n\n                     vector<double> cD_undec;\n                     convfftm(signal,hp1,cD_undec);\n                     cD_undec.erase(cD_undec.begin(),cD_undec.begin()+lf);\n                     cD_undec.erase(cD_undec.end()-lf+1,cD_undec.end());\n                     downsamp(cD_undec,D,cD);\n                  //   cD.erase(cD.begin(),cD.begin()+(int) ceil(((double)lf-1.0)/2.0));\n                  //   cD.erase(cD.end()-(int) ceil(((double)lf-1.0)/2.0),cD.end());\n\n                filtcoef(wname,lp1,hp1,lp2,hp2);\n\n  return 0;\n}\n\nvoid* dwt_sym(vector<double> &signal, int J,string nm, vector<double> &dwt_output,\n                vector<double> &flag, vector<int> &length){\n\n    unsigned int temp_len = signal.size();\n        if ( (temp_len % 2) != 0) {\n                double temp =signal[temp_len - 1];\n                signal.push_back(temp);\n                flag.push_back(1);\n                temp_len++;\n        } else {\n                flag.push_back(0);\n        }\n        length.push_back(temp_len);\n        flag.push_back(double(J));\n        // flag[2] contains symmetric extension length\n\n\n    vector<double> original_copy, appx_sig, det_sig;\n    original_copy = signal;\n\n\n        //  Storing Filter Values for GnuPlot\n             vector<double> lp1,hp1,lp2,hp2;\n             filtcoef(nm,lp1,hp1,lp2,hp2);\n        for (int iter = 0; iter < J; iter++) {\n            dwt1_sym(nm,signal, appx_sig, det_sig);\n                dwt_output.insert(dwt_output.begin(),det_sig.begin(),det_sig.end());\n            int l_temp = det_sig.size();\n            length.insert(length.begin(),l_temp);\n\n            if (iter == J-1 ) {\n                dwt_output.insert(dwt_output.begin(),appx_sig.begin(),appx_sig.end());\n                int l_temp = appx_sig.size();\n                length.insert(length.begin(),l_temp);\n\n            }\n\n            signal.clear();\n            signal = appx_sig;\n            appx_sig.clear();\n            det_sig.clear();\n\n        }\n         signal = original_copy;\n\nreturn 0;\n}\n\n\nvoid* freq(vector<double> &sig, vector<double> &freq_resp) {\n         unsigned int K = sig.size();\n            unsigned int N = (unsigned int) pow(2.0,ceil(log10 (static_cast<double>(K))/log10(2.0)));\n            vector<complex<double> > fft_oup;\n            for (unsigned int i =0; i < sig.size(); i++) {\n                 double temp = sig[i];\n                 fft_oup.push_back(complex<double>(temp,0));\n            }\n            fft(fft_oup,1,N);\n\n            for (unsigned int i = 0; i < N; i++){\n                double temp = abs(fft_oup[i]);\n                freq_resp.push_back(temp);\n            }\n            circshift(freq_resp, N/2);\n            return 0;\n}\n\ndouble convfft(vector<double> &a, vector<double> &b, vector<double> &c) {\n    fftw_complex *inp_data, *filt_data, *inp_fft, *filt_fft, *temp_data, *temp_ifft;\n    fftw_plan plan_forward_inp,plan_forward_filt, plan_backward;\n\n    unsigned int sz = a.size() + b.size() - 1;\n    inp_data = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n    filt_data = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n\n    inp_fft = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n    filt_fft = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n\n    temp_data = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n    temp_ifft = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n\n    plan_forward_inp  = fftw_plan_dft_1d( sz, inp_data, inp_fft, FFTW_FORWARD, FFTW_ESTIMATE );\n    plan_forward_filt  = fftw_plan_dft_1d( sz, filt_data, filt_fft, FFTW_FORWARD, FFTW_ESTIMATE );\n    plan_backward = fftw_plan_dft_1d( sz, temp_data, temp_ifft, FFTW_BACKWARD, FFTW_ESTIMATE );\n\n\n    for (unsigned int i =0; i < sz; i++) {\n         if (i < a.size()) {\n        inp_data[i][0] = a[i];\n         } else {\n            inp_data[i][0] = 0.0;\n\n         }\n        inp_data[i][1] = 0.0;\n        if (i < b.size()) {\n                filt_data[i][0] = b[i];\n           } else {\n                filt_data[i][0] = 0.0;\n\n           }\n        filt_data[i][1] = 0.0;\n\n    }\n\n\n\n    fftw_execute(plan_forward_inp);\n\n    fftw_execute(plan_forward_filt);\n\n    for (unsigned int i =0; i < sz; i++){\n         temp_data[i][0] = inp_fft[i][0]*filt_fft[i][0] - inp_fft[i][1]*filt_fft[i][1];\n\n         temp_data[i][1] = inp_fft[i][0]*filt_fft[i][1] + inp_fft[i][1]*filt_fft[i][0];\n\n\n\n    }\n\n\n    fftw_execute(plan_backward);\n\n    for (unsigned int i = 0; i < sz; i++) {\n        double temp1;\n        temp1 = temp_ifft[i][0] / (double) sz;\n        c.push_back(temp1);\n\n    }\n    fftw_free(inp_data);\n    fftw_free(filt_data);\n    fftw_free(inp_fft);\n    fftw_free(filt_fft);\n    fftw_free(temp_data);\n    fftw_free(temp_ifft);\n    fftw_destroy_plan(plan_forward_inp);\n    fftw_destroy_plan(plan_forward_filt);\n    fftw_destroy_plan(plan_backward);\n\n    return 0;\n}\n\ndouble convfftm(vector<double> &a, vector<double> &b, vector<double> &c) {\n    fftw_complex *inp_data, *filt_data, *inp_fft, *filt_fft, *temp_data, *temp_ifft;\n\n    unsigned int sz = a.size() + b.size() - 1;\n    inp_data = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n    filt_data = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n\n    inp_fft = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n    filt_fft = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n\n    temp_data = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n    temp_ifft = ( fftw_complex* ) fftw_malloc( sizeof( fftw_complex ) * sz );\n\n    if (sz != transient_size_of_fft) {\n\n        if (transient_size_of_fft != 0) {\n            fftw_destroy_plan(plan_forward_inp);\n            fftw_destroy_plan(plan_forward_filt);\n            fftw_destroy_plan(plan_backward);\n        }\n\n    plan_forward_inp  = fftw_plan_dft_1d( sz, inp_data, inp_fft, FFTW_FORWARD, FFTW_MEASURE );\n    plan_forward_filt  = fftw_plan_dft_1d( sz, filt_data, filt_fft, FFTW_FORWARD, FFTW_MEASURE );\n    plan_backward = fftw_plan_dft_1d( sz, temp_data, temp_ifft, FFTW_BACKWARD, FFTW_MEASURE );\n    transient_size_of_fft = sz;\n\n}\n\n    for (unsigned int i =0; i < sz; i++) {\n         if (i < a.size()) {\n        inp_data[i][0] = a[i];\n         } else {\n            inp_data[i][0] = 0.0;\n\n         }\n        inp_data[i][1] = 0.0;\n        if (i < b.size()) {\n                filt_data[i][0] = b[i];\n           } else {\n                filt_data[i][0] = 0.0;\n\n           }\n        filt_data[i][1] = 0.0;\n\n    }\n\n\n    fftw_execute_dft( plan_forward_inp,inp_data, inp_fft);\n    fftw_execute_dft( plan_forward_filt,filt_data, filt_fft);\n\n\n\n    for (unsigned int i =0; i < sz; i++){\n         temp_data[i][0] = inp_fft[i][0]*filt_fft[i][0] - inp_fft[i][1]*filt_fft[i][1];\n\n         temp_data[i][1] = inp_fft[i][0]*filt_fft[i][1] + inp_fft[i][1]*filt_fft[i][0];\n\n\n\n    }\n\n    fftw_execute_dft( plan_backward, temp_data, temp_ifft);\n\n\n    for (unsigned int i = 0; i < sz; i++) {\n        double temp1;\n        temp1 = temp_ifft[i][0] / (double) sz;\n        c.push_back(temp1);\n\n    }\n    fftw_free(inp_data);\n    fftw_free(filt_data);\n    fftw_free(inp_fft);\n    fftw_free(filt_fft);\n    fftw_free(temp_data);\n    fftw_free(temp_ifft);\n\n    return 0;\n}\n\nvoid* fft(vector<complex<double> > &data, int sign,unsigned  int N){\n        double pi = - 3.14159265358979;\n        if ( sign == 1 || sign == -1) {\n        pi = sign * pi;\n        } else {\n                cout << \"Format fft(data, num), num = +1(fft) and num = -1 (Ifft)\"  << endl;\n            exit(1);\n        }\n        unsigned int len = data.size();\n        vector<complex<double> >::iterator it;\n        it = data.end();\n        if ( len != N) {\n                unsigned int al = N - len;\n        data.insert(it,al,complex<double>(0,0));\n        }\n\n        unsigned int K = (unsigned int) pow(2.0,ceil(log10(static_cast<double>(N))/log10(2.0)));\n        vector<complex<double> >::iterator it1;\n        it1 = data.end();\n        if ( N < K) {\n                unsigned int al = K - N;\n                data.insert(it1,al,complex<double>(0,0));\n                N = K;\n        }\n\n      bitreverse(data);\n\n//\t radix2(data);\n         for (unsigned int iter = 1; iter < N; iter <<=1)\n            {\n               const unsigned int step = iter << 1;\n\n               const double theta =  pi / double(iter);\n\n               double wtemp = sin(theta * .5);\n               //   Multipliers\n               double wreal = -2 * wtemp * wtemp;\n               double wimag = sin(theta);\n\n               //   Factors\n               double wr = 1.0;\n               double wi = 0.0;\n               //   Iteration through two loops\n\n               for (unsigned int m = 0; m < iter; m++)\n               {\n                  //   Iteration within m\n                  for (unsigned int i = m; i < N; i += step)\n                  {\n                     //   jth position\n                     const unsigned int j = i + iter;\n\n                     double tempr= wr * real(data[j]) - wi * imag(data[j]);\n                     double tempi= wr * imag(data[j]) + wi * real(data[j]);\n\n                                 complex<double> temp(tempr,tempi);\n                                 data[j]= data[i]- temp;\n                                 data[i] += temp;\n\n                  }\n                  //   Twiddle Factors updated\n              wtemp = wr;\n                  wr += wr * wreal - wi * wimag;\n                  wi += wi * wreal + wtemp * wimag ;\n               }\n\n            }\n\n         if ( sign == -1) {\n                 double scale = 1.0/double(N);\n                 for (unsigned int i = 0; i < N; i++){\n                         data[i]*=scale;\n                 }\n         }\n\n\n\n        // Place holder\n        return 0;\n}\n\n\nvoid* bitreverse(vector<complex<double> > &sig) {\n        unsigned int len = sig.size();\n        unsigned int N = (unsigned int) pow(2.0,ceil(log10(static_cast<double>(len))/log10(2.0)));\n         unsigned int rev = 0;\n           //   Processing Input Data\n           for (unsigned int iter = 0; iter < N; ++iter)\n           {\n              if (rev > iter)\n              {\n                 //   Replacing current values with reversed values\n\n                 double tempr = real(sig[rev]);\n                         double tempi = imag(sig[rev]);\n                         complex<double> temp(tempr,tempi);\n                         sig[rev] = sig[iter];\n                         sig[iter] = temp;\n\n              }\n              //   Using filter \"filt\" such that the value of reverse changes with each iteration\n              unsigned int filt = N;\n              while (rev & (filt >>= 1)) {\n                 rev &= ~filt;\n              }\n              rev |= filt;\n           }\n           return 0;\n\n}\n\n\nvoid* dwt(vector<double> &sig, int J, string nm, vector<double> &dwt_output\n                , vector<double> &flag, vector<int> &length ) {\n\n        int Max_Iter;\n                    Max_Iter = (int) ceil(log( double(sig.size()))/log (2.0)) - 2;\n\n                    if ( Max_Iter < J) {\n                      J = Max_Iter;\n\n                    }\n\n    vector<double> original_copy,orig, appx_sig, det_sig;\n    original_copy = sig;\n\n    // Zero Pad the Signal to nearest 2^ M value ,where M is an integer.\n    unsigned int temp_len = sig.size();\n        if ( (temp_len % 2) != 0) {\n                double temp =sig[temp_len - 1];\n                sig.push_back(temp);\n                flag.push_back(1);\n                temp_len++;\n        } else {\n                flag.push_back(0);\n        }\n        length.push_back(temp_len);\n        flag.push_back(double(J));\n\n    orig = sig;\n\n\n        //  Storing Filter Values for GnuPlot\n             vector<double> lp1,hp1,lp2,hp2;\n             filtcoef(nm,lp1,hp1,lp2,hp2);\n\n\n    for (int iter = 0; iter < J; iter++) {\n        dwt1(nm,orig, appx_sig, det_sig);\n        dwt_output.insert(dwt_output.begin(),det_sig.begin(),det_sig.end());\n\n        int l_temp = det_sig.size();\n        length.insert(length.begin(),l_temp);\n\n        if (iter == J-1 ) {\n                dwt_output.insert(dwt_output.begin(),appx_sig.begin(),appx_sig.end());\n                int l_temp2 = appx_sig.size();\n                length.insert(length.begin(),l_temp2);\n\n        }\n\n        orig = appx_sig;\n        appx_sig.clear();\n        det_sig.clear();\n\n    }\n\n     sig = original_copy;\n        return 0;\n}\n\n\nvoid circshift(vector<double> &sig_cir, int L){\n        if ( abs(L) >(signed int) sig_cir.size()) {\n                L = sign(L) * (abs(L) % sig_cir.size());\n        }\n\n        if ( L < 0 ){\n                L = (sig_cir.size() + L) % sig_cir.size();\n        //\tcout << \"L\" << L << endl;\n        }\n                for (int i = 0; i < L; i++){\n                        sig_cir.push_back(sig_cir[0]);\n                        sig_cir.erase(sig_cir.begin());\n                }\n\n}\n\ndouble convol(vector<double> &a1, vector<double> &b1, vector<double> &c) {\n     unsigned int len_c = a1.size() + b1.size() - 1;\n     vector<double> a = a1;\n     vector<double> b = b1;\n     double*  oup= NULL;\n\n     oup = new double[len_c];\n     vector<double>::iterator a_it;\n     a_it = a.end();\n     signed int al = len_c - a.size();\n     a.insert(a_it,al,0);\n\n\n     vector<double>::iterator b_it;\n     b_it = b.end();\n     signed int bl = len_c - b.size();\n     b.insert(b_it,bl, 0);\n\n\n     for (unsigned int ini = 0; ini < len_c ; ini++){\n         double ou1 = 0;\n         oup[ini] = 0;\n         double temp = 0;\n         for (unsigned int jni = 0; jni <= ini; jni++) {\n                 ou1 = a[jni] * b[ini - jni];\n                 oup[ini]+= ou1;\n         }\n         temp = oup[ini];\n         c.push_back(temp);\n     }\n     delete [] oup;\n     oup = NULL;\n     return 0;\n}\n\nvoid downsamp(vector<double> &sig, int M, vector<double> &sig_d){\n        int len = sig.size();\n        double len_n = ceil( (double) len / (double) M);\n        for (int i = 0; i < (int) len_n; i++) {\n                double temp = sig[i*M];\n                sig_d.push_back(temp);\n        }\n}\n\n\n\n\n\nvoid* dwt1(string wname, vector<double> &signal, vector<double> &cA, vector<double> &cD) {\n\n        vector<double> lpd, hpd, lpr, hpr;\n\n                filtcoef(wname,lpd,hpd,lpr,hpr);\n\n                int len_lpfilt = lpd.size();\n                int len_hpfilt = hpd.size();\n                int len_avg = (len_lpfilt + len_hpfilt) / 2;\n                int len_sig = 2 * (int) ceil((double) signal.size() / 2.0);\n\n                // cout << len_lpfilt << \"Filter\" << endl;\n                per_ext(signal,len_avg / 2); // Periodic Extension\n                // computations designed to deal with boundary distortions\n\n                // Low Pass Filtering Operations in the Analysis Filter Bank Section\n//\t\tint len_cA =(int)  floor(double (len_sig + len_lpfilt -1) / double (2));\n                vector<double> cA_undec;\n                // convolving signal with lpd, Low Pass Filter, and O/P is stored in cA_undec\n                convfft(signal,lpd,cA_undec);\n                int D = 2; // Downsampling Factor is 2\n                cA_undec.erase(cA_undec.begin(),cA_undec.begin()+len_avg-1);\n                cA_undec.erase(cA_undec.end()-len_avg+1,cA_undec.end());\n                cA_undec.erase(cA_undec.begin()+len_sig,cA_undec.end());\n                cA_undec.erase(cA_undec.begin());\n\n\n                // Downsampling by 2 gives cA\n                downsamp(cA_undec, D, cA);\n\n          //     cA.erase(cA.begin(),cA.begin()+len_avg/2);\n          //      cA.erase(cA.end()-len_avg/2,cA.end());\n\n                // High Pass Filtering Operations in the Analysis Filter Bank Section\n//\t\tint len_cA =(int)  floor(double (len_sig + len_lpfilt -1) / double (2));\n\n                vector<double> cD_undec;\n                // convolving signal with lpd, Low Pass Filter, and O/P is stored in cA_undec\n                convfft(signal,hpd,cD_undec);\n                cD_undec.erase(cD_undec.begin(),cD_undec.begin()+len_avg-1);\n                cD_undec.erase(cD_undec.end()-len_avg+1,cD_undec.end());\n                cD_undec.erase(cD_undec.begin()+len_sig,cD_undec.end());\n                cD_undec.erase(cD_undec.begin());\n\n                 // Downsampling Factor is 2\n\n                // Downsampling by 2 gives cA\n                downsamp(cD_undec, D, cD);\n\n    //            cD.erase(cD.begin(),cD.begin()+len_avg/2);\n      //          cD.erase(cD.end()-len_avg/2,cD.end());\n\n                filtcoef(wname,lpd,hpd,lpr,hpr);\n\n  return 0;\n}\n\nvoid* dwt1_m(string wname, vector<double> &signal, vector<double> &cA, vector<double> &cD) {\n\n        vector<double> lpd, hpd, lpr, hpr;\n\n                filtcoef(wname,lpd,hpd,lpr,hpr);\n\n                int len_lpfilt = lpd.size();\n                int len_hpfilt = hpd.size();\n                int len_avg = (len_lpfilt + len_hpfilt) / 2;\n                int len_sig = 2 * (int) ceil((double) signal.size() / 2.0);\n\n                // cout << len_lpfilt << \"Filter\" << endl;\n                per_ext(signal,len_avg / 2); // Periodic Extension\n                // computations designed to deal with boundary distortions\n\n                // Low Pass Filtering Operations in the Analysis Filter Bank Section\n//\t\tint len_cA =(int)  floor(double (len_sig + len_lpfilt -1) / double (2));\n                vector<double> cA_undec;\n                // convolving signal with lpd, Low Pass Filter, and O/P is stored in cA_undec\n                convfftm(signal,lpd,cA_undec);\n                int D = 2; // Downsampling Factor is 2\n                cA_undec.erase(cA_undec.begin(),cA_undec.begin()+len_avg-1);\n                cA_undec.erase(cA_undec.end()-len_avg+1,cA_undec.end());\n                cA_undec.erase(cA_undec.begin()+len_sig,cA_undec.end());\n                cA_undec.erase(cA_undec.begin());\n\n\n                // Downsampling by 2 gives cA\n                downsamp(cA_undec, D, cA);\n\n          //     cA.erase(cA.begin(),cA.begin()+len_avg/2);\n          //      cA.erase(cA.end()-len_avg/2,cA.end());\n\n                // High Pass Filtering Operations in the Analysis Filter Bank Section\n//\t\tint len_cA =(int)  floor(double (len_sig + len_lpfilt -1) / double (2));\n\n                vector<double> cD_undec;\n                // convolving signal with lpd, Low Pass Filter, and O/P is stored in cA_undec\n                convfftm(signal,hpd,cD_undec);\n                cD_undec.erase(cD_undec.begin(),cD_undec.begin()+len_avg-1);\n                cD_undec.erase(cD_undec.end()-len_avg+1,cD_undec.end());\n                cD_undec.erase(cD_undec.begin()+len_sig,cD_undec.end());\n                cD_undec.erase(cD_undec.begin());\n\n                 // Downsampling Factor is 2\n\n                // Downsampling by 2 gives cA\n                downsamp(cD_undec, D, cD);\n\n    //            cD.erase(cD.begin(),cD.begin()+len_avg/2);\n      //          cD.erase(cD.end()-len_avg/2,cD.end());\n\n                filtcoef(wname,lpd,hpd,lpr,hpr);\n\n  return 0;\n}\n\n\nvoid* dyadic_zpad_1d(vector<double> &signal) {\n        unsigned int N = signal.size();\n        double M = log10 (static_cast<double> (N)) / log10(2.0);\n        int D = (int) ceil(M);\n        double int_val = pow(2.0, double(D)) - pow(2.0, M);\n\n        int z = (int) int_val;\n    vector<double>::iterator a_it;\n    a_it = signal.end();\n    double val = signal[N-1];\n  //  double val = 0;\n    signal.insert(a_it,z,val);\n    return 0;\n\n}\n\n\nvoid* idwt(vector<double> &dwtop,vector<double> &flag, string nm,\n                vector<double> &idwt_output,vector<int> &length) {\n\n        int J =(int) flag[1];\n //       int zpad =(int) flag[0];\n\n\n            vector<double> app;\n            vector<double> detail;\n            unsigned int app_len = length[0];\n            unsigned int det_len = length[1];\n\n        vector<double>::iterator dwt;\n        dwt = dwtop.begin();\n        app.assign(dwt,dwtop.begin()+app_len);\n        detail.assign(dwtop.begin()+app_len, dwtop.begin()+ 2* app_len);\n\n            for (int i = 0; i < J; i++) {\n\n                idwt1(nm,idwt_output, app,detail);\n                app_len +=det_len;\n                app.clear();\n                detail.clear();\n                        if ( i < J - 1 ) {\n                            det_len = length[i+2];\n                            for (unsigned int l = 0; l < det_len;l++) {\n\n                                double temp = dwtop[app_len + l];\n                                detail.push_back(temp);\n                            }\n                            app = idwt_output;\n\n                            if (app.size() >= detail.size()){\n                                int t = app.size() - detail.size();\n                               int lent = (int) floor((double)t/2.0);\n                               app.erase(app.begin()+detail.size()+lent,app.end());\n                               app.erase(app.begin(),app.begin()+lent);\n                            }\n                        }\n\n\n\n\n//            int value1 = (int) ceil((double)(app.size() - det_len)/2.0);\n//           int value2 = (int) floor((double)(app.size() - det_len)/2.0);\n\n//            app.erase(app.end() -value2,app.end());\n//           app.erase(app.begin(),app.begin()+value1);\n\n            }\n\n\n            // Remove ZeroPadding\n\n            int zerop =(int) flag[0];\n            idwt_output.erase(idwt_output.end()- zerop,idwt_output.end());\n\n            return 0;\n}\n\nvoid* idwt1_m(string wname, vector<double> &X, vector<double> &cA, vector<double> &cD) {\n        vector<double> lpd1,hpd1, lpr1, hpr1;\n\n        filtcoef(wname,lpd1,hpd1,lpr1,hpr1);\n        int len_lpfilt = lpr1.size();\n        int len_hpfilt = hpr1.size();\n        int len_avg = (len_lpfilt + len_hpfilt) / 2;\n        unsigned int N = 2 * cD.size();\n        int U = 2; // Upsampling Factor\n\n        // Operations in the Low Frequency branch of the Synthesis Filter Bank\n\n        vector<double> cA_up;\n        vector<double> X_lp;\n       // int len1 = cA_up.size();\n        upsamp(cA, U, cA_up);\n\n        per_ext(cA_up,len_avg/2);\n\n\n        convfftm(cA_up, lpr1, X_lp);\n\n\n        // Operations in the High Frequency branch of the Synthesis Filter Bank\n\n        vector<double> cD_up;\n        vector<double> X_hp;\n        upsamp(cD, U, cD_up);\n        per_ext(cD_up,len_avg/2);\n\n\n        convfftm(cD_up, hpr1, X_hp);\n\n   // Remove periodic extension\n\n     //   X.erase(X.begin(),X.begin()+len_avg+len_avg/2-1);\n     //   X.erase(X.end()-len_avg-len_avg/2,X.end());\n\n\n        X_lp.erase(X_lp.begin()+N+len_avg-1,X_lp.end());\n        X_lp.erase(X_lp.begin(),X_lp.begin()+len_avg-1);\n\n        X_hp.erase(X_hp.begin()+N+len_avg-1,X_hp.end());\n        X_hp.erase(X_hp.begin(),X_hp.begin()+len_avg-1);\n\n\n        vecsum(X_lp,X_hp,X);\n\n\n    return 0;\n}\n\nvoid* idwt1(string wname, vector<double> &X, vector<double> &cA, vector<double> &cD) {\n        vector<double> lpd1,hpd1, lpr1, hpr1;\n\n        filtcoef(wname,lpd1,hpd1,lpr1,hpr1);\n        int len_lpfilt = lpr1.size();\n        int len_hpfilt = hpr1.size();\n        int len_avg = (len_lpfilt + len_hpfilt) / 2;\n        unsigned int N = 2 * cD.size();\n        int U = 2; // Upsampling Factor\n\n        // Operations in the Low Frequency branch of the Synthesis Filter Bank\n\n        vector<double> cA_up;\n        vector<double> X_lp;\n       // int len1 = cA_up.size();\n        upsamp(cA, U, cA_up);\n\n        per_ext(cA_up,len_avg/2);\n\n\n        convfft(cA_up, lpr1, X_lp);\n\n\n        // Operations in the High Frequency branch of the Synthesis Filter Bank\n\n        vector<double> cD_up;\n        vector<double> X_hp;\n        upsamp(cD, U, cD_up);\n        per_ext(cD_up,len_avg/2);\n\n\n        convfft(cD_up, hpr1, X_hp);\n\n   // Remove periodic extension\n\n     //   X.erase(X.begin(),X.begin()+len_avg+len_avg/2-1);\n     //   X.erase(X.end()-len_avg-len_avg/2,X.end());\n\n\n        X_lp.erase(X_lp.begin()+N+len_avg-1,X_lp.end());\n        X_lp.erase(X_lp.begin(),X_lp.begin()+len_avg-1);\n\n        X_hp.erase(X_hp.begin()+N+len_avg-1,X_hp.end());\n        X_hp.erase(X_hp.begin(),X_hp.begin()+len_avg-1);\n\n\n        vecsum(X_lp,X_hp,X);\n\n\n    return 0;\n}\n\nint sign(int X) {\n        if (X >= 0)\n                return 1;\n        else\n                return -1;\n}\n\nvoid upsamp(vector<double> &sig, int M, vector<double> &sig_u) {\n        int len = sig.size();\n        double len_n = ceil( (double) len * (double) M);\n\n        for (int i = 0; i < (int) len_n; i++) {\n                if ( i % M == 0) {\n                                double temp = sig[i / M];\n                                        sig_u.push_back(temp);\n\n                                }\n                                else\n                                {\n                                         sig_u.push_back(0);\n                                }\n\n        }\n\n\n\n}\n\ndouble op_sum(double i, double j) {\n        return (i+j);\n}\n\nint vecsum(vector<double> &a, vector<double> &b, vector<double> &c){\n\n\n    c.resize(a.size());\n        transform (a.begin(), a.end(), b.begin(), b.begin(), op_sum);\n        c = b;\n                return 0;\n}\n\nvoid* getcoeff2d(vector<vector<double> > &dwtoutput, vector<vector<double> > &cH,\n                vector<vector<double> > &cV,vector<vector<double> > &cD,vector<double> &flag, int &N) {\n        if (N > flag[2]) {\n                cout << \"Signal is decimated only up to \" << flag[2] << \" levels\" << endl;\n                exit(1);\n        }\n        int rows = dwtoutput.size();\n        int cols = dwtoutput[0].size();\n    // Getting Horizontal Coefficients\n        int r = (int) ceil((double) rows /pow(2.0,N)) ;\n        int c = (int) ceil((double) cols /pow(2.0,N)) ;\n\n        for (int i =0; i < (int) ceil ((double) rows /pow(2.0,N)); i++){\n                for (int j =0; j < (int) ceil ((double) cols /pow(2.0,N)); j++) {\n                        cH[i][j]=dwtoutput[i][c+ j];\n                }\n        }\n\n\n        for (int i =0; i < (int) ceil ((double) rows /pow(2.0,N)); i++){\n                for (int j =0; j < (int) ceil ((double) cols /pow(2.0,N)); j++) {\n                        cV[i][j]=dwtoutput[i + r][j];\n                }\n        }\n\n        for (int i =0; i < (int) ceil ((double) rows /pow(2.0,N)); i++){\n                for (int j =0; j < (int) ceil ((double) cols /pow(2.0,N)); j++) {\n                        cD[i][j]=dwtoutput[i + r][c+ j];\n                }\n        }\n\n  return 0;\n}\n\nvoid* zero_remove(vector<vector<double> > &input,vector<vector<double> > &output) {\n        int zero_rows = output.size()-input.size();\n        int zero_cols = output[0].size()-input[0].size();\n\n        vector<vector<double> >::iterator row = output.end()-zero_rows;\n\n\n   unsigned int ousize = output.size();\n        for (unsigned int i = input.size(); i < ousize; i++){\n    output.erase(row);\n    row++;\n\n        }\n\n//\tunsigned int ousize2 = output[0].size();\n\n\n        for (unsigned int i = 0; i < ousize; i++){\n    vector<double> ::iterator col = output[i].end()-zero_cols;\n\n    output[i].erase(col, output[i].end());\n\n        }\n        return 0;\n}\n\nvoid* dwt_output_dim(vector<vector<double> >&signal, int &r, int &c ){\n           int rows =signal.size();\n           int cols = signal[0].size();\n\n                double Mr = log10 (static_cast<double> (rows)) / log10(2.0);\n                int Dr = (int) ceil(Mr);\n                double int_val_row = pow(2.0, double(Dr));\n                int r1 = (int) int_val_row;\n\n                double Mc = log10 (static_cast<double> (cols)) / log10(2.0);\n                int Dc = (int) ceil(Mc);\n                double int_val_cols = pow(2.0, double(Dc));\n        int c1 = (int) int_val_cols;\n        r=max(r1,c1);\n        c=max(r1,c1);\n\n        return 0;\n\n}\n\nvoid* dyadic_zpad_2d(vector<vector<double> > &signal,vector<vector<double> > &mod){\n   int rows =signal.size();\n   int cols = signal[0].size();\n\n        for (int i=0; i < rows; i++) {\n                for (int j = 0; j < cols; j++){\n                        mod[i][j] = signal[i][j];\n                }\n\n        }\n   // Zeropadding the columns\n\n        double Mr = log10 (static_cast<double> (rows)) / log10(2.0);\n        int Dr = (int) ceil(Mr);\n        double int_val_row = pow(2.0, double(Dr)) - pow(2.0, Mr);\n\n        int zeros_row = (int) int_val_row;\n\n        double Mc = log10 (static_cast<double> (cols)) / log10(2.0);\n        int Dc = (int) ceil(Mc);\n        double int_val_cols = pow(2.0, double(Dc)) - pow(2.0, Mc);\n\n        int zeros_cols = (int) int_val_cols;\n\n        for (int i=0; i < rows + zeros_row; i++) {\n                for (int j = cols; j < cols+zeros_cols; j++){\n\n                        mod[i][j] = 0;\n                }\n\n        }\n\n        for (int i= rows; i < rows + zeros_row; i++) {\n                for (int j = 0; j < cols+zeros_cols; j++){\n                        mod[i][j] = 0;\n                }\n\n        }\n\n        return 0;\n\n}\n\nvoid* idwt_2d(vector<double>  &dwtop,vector<double> &flag, string nm,\n                vector<vector<double> > &idwt_output, vector<int> &length){\n    int J =(int) flag[0];\n    int rows =length[0];\n    int cols =length[1];\n\n    int sum_coef =0;\n    vector<double> lp1,hp1,lp2,hp2;\n    filtcoef(nm,lp1,hp1,lp2,hp2);\n        vector<vector<double> >  cLL(rows, vector<double>(cols));\n\n\n    for (int iter=0; iter < J; iter++) {\n\n        int rows_n = length[2*iter];\n        int cols_n = length[2*iter + 1];\n\n        vector<vector<double> >  cLH(rows_n, vector<double>(cols_n));\n        vector<vector<double> >  cHL(rows_n, vector<double>(cols_n));\n        vector<vector<double> >  cHH(rows_n, vector<double>(cols_n));\n\n        for (int i = 0 ; i < rows_n; i++ ){\n                for (int j = 0; j < cols_n; j++){\n                        if (iter == 0) {\n                        cLL[i][j] = dwtop[sum_coef+ i * cols_n + j];\n\n                cLH[i][j] = dwtop[sum_coef+ rows_n * cols_n+ i * cols_n + j];\n\n                cHL[i][j] = dwtop[sum_coef+ 2 * rows_n * cols_n + i * cols_n + j];\n\n                cHH[i][j] = dwtop[sum_coef+ 3* rows_n * cols_n + i * cols_n + j];\n                        } else {\n\n                        cLH[i][j] = dwtop[sum_coef+  i * cols_n + j];\n\n                        cHL[i][j] = dwtop[sum_coef+ rows_n * cols_n + i * cols_n + j];\n\n                    cHH[i][j] = dwtop[sum_coef+ 2* rows_n * cols_n + i * cols_n + j];\n\n                        }\n                }\n        }\n\n\n  //      temp_A = cLL;\n  //  \tidwt2_sym(nm,idwt_output2, cA, cH,cV,cD);\n\n        unsigned int len_x = cLH.size();\n        unsigned int len_y = cLH[0].size();\n\n        // Row Upsampling and Column Filtering at the first LP Stage\n        vector<vector<double> > cL(2 *len_x,vector<double>(len_y ));\n        vector<vector<double> > cH(2 * len_x ,vector<double>(len_y ));\n\n        if (iter ==0) {\n        for (unsigned int j =0; j < len_y; j++) {\n\n                        vector<double> sigLL,sigLH,oup;\n\n                        for (unsigned int i=0;i <  len_x;i++) {\n\n                                double temp1 = cLL[i][j];\n                                double temp2 = cLH[i][j];\n                                sigLL.push_back(temp1);\n                                sigLH.push_back(temp2);\n                        }\n                        idwt1_m(nm,oup,sigLL,sigLH);\n\n                                for (int i=0;i < (int) oup.size();i++) {\n                                cL[i][j] = oup[i];\n                                }\n\n                }\n        } else{\n                unsigned int rows1 =cLH.size();\n                unsigned int cols1 =cLH[0].size();\n\n                for (unsigned int j =0; j < cols1;j++){\n                        vector<double> temp_L1,temp_L2,oup;\n                        for (unsigned int i =0; i < rows1; i++){\n                                double temp = cLL[i][j];\n                                temp_L1.push_back(temp);\n\n                                double temp2 = cLH[i][j];\n                                temp_L2.push_back(temp2);\n                        }\n                        idwt1_m(nm,oup,temp_L1,temp_L2);\n\n                                for (unsigned int i =0; i < oup.size(); i++){\n                                        cL[i][j]=oup[i];\n                                }\n\n               }\n            }\n\n\n        for (unsigned int j =0; j < len_y; j++) {\n                        vector<double> sigHL,sigHH,oup2;\n                        for (unsigned int i=0;i <  len_x;i++) {\n                                double temp3 = cHL[i][j];\n                                double temp4 = cHH[i][j];\n                                sigHL.push_back(temp3);\n                                sigHH.push_back(temp4);\n                        }\n                        idwt1_m(nm,oup2,sigHL,sigHH);\n\n                                for (int i=0;i < (int) oup2.size();i++) {\n                                cH[i][j] = oup2[i];\n                                }\n\n                }\n\n       vector<vector<double> > signal(2*len_x,vector<double>(2 *len_y ));\n        for (unsigned int i =0; i < 2 * len_x ; i++) {\n                        vector<double> sigL,sigH,oup;\n                        for (unsigned int j=0;j <  len_y;j++) {\n                                double temp5 = cL[i][j];\n                                double temp6 = cH[i][j];\n                                sigL.push_back(temp5);\n                                sigH.push_back(temp6);\n                        }\n                        idwt1_m(nm,oup,sigL,sigH);\n\n                                for (int j=0;j < (int) oup.size();j++) {\n                                signal[i][j] = oup[j];\n                                }\n\n                }\n\n        idwt_output = signal;\n\n\n\n       if (iter ==0) {\n           sum_coef+= 4 *rows_n * cols_n;\n       } else {\n           sum_coef+= 3 *rows_n * cols_n;\n       }\n   cLL = signal;\n\n\n    }\n\n\n        return 0;\n}\n\n\n\nvoid* dwt_2d(vector<vector<double> > &origsig, int J, string nm, vector<double> &dwt_output\n                , vector<double> &flag , vector<int> &length) {\n// flag will contain\n\n   vector<vector<double> >  sig = origsig;\n        int rows_n = sig.size(); // No. of rows\n    int cols_n = sig[0].size(); //No. of columns\n    vector<vector<double> > original_copy(rows_n,vector<double>(cols_n));\n\n        original_copy = sig;\n        int Max_Iter;\n                    Max_Iter = min((int) ceil(log( double(sig.size()))/log (2.0)),(int) ceil(log( double(sig[0].size()))/log (2.0)));\n                    if ( Max_Iter < J) {\n                        cout << J << \" Iterations are not possible with signals of this dimension \"  << endl;\n                        exit(1);\n                    }\n                    vector<double> lp1,hp1,lp2,hp2;\n\n                    flag.push_back(double(J));\n                    flag.push_back(0);\n\n\n                     length.insert(length.begin(),cols_n);\n                     length.insert(length.begin(),rows_n);\n\n\n                int sum_coef = 0;\n                 for (int iter = 0; iter < J; iter++) {\n                 filtcoef(nm,lp1,hp1,lp2,hp2);\n\n                        rows_n =(int) ceil((double)rows_n /2.0);\n                        cols_n =(int) ceil((double) cols_n/2.0);\n                        length.insert(length.begin(),cols_n);\n                        length.insert(length.begin(),rows_n);\n\n                                vector<vector<double> >  cA(rows_n, vector<double>(cols_n));\n                                vector<vector<double> >  cH(rows_n, vector<double>(cols_n));\n                                vector<vector<double> >  cV(rows_n, vector<double>(cols_n));\n                                vector<vector<double> >  cD(rows_n, vector<double>(cols_n));\n\n                                if (iter == 0) {\n                                dwt2(nm,original_copy,cA,cH,cV,cD);\n                                } else {\n                                        dwt2(nm,original_copy,cA,cH,cV,cD);\n\n                                }\n                                vector<double>   temp_sig2;\n\n                    original_copy = cA;\n                    if (iter == J-1) {\n                                for(int i =0; i < rows_n; i++){\n                                        for (int j =0; j < cols_n; j++){\n                                        double temp=cA[i][j];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n                    }\n                                for(int i =0; i < rows_n; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                        double temp =cH[i][j - cols_n];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j =0; j < cols_n; j++){\n                                        double temp=cV[i - rows_n][j];\n                                        temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                for(int i = rows_n; i < rows_n * 2; i++){\n                                        for (int j = cols_n; j < cols_n * 2; j++){\n                                        double temp =cD[i- rows_n][j - cols_n];\n                                         temp_sig2.push_back(temp);\n                                        }\n                                }\n\n                                dwt_output.insert(dwt_output.begin(),temp_sig2.begin(),temp_sig2.end());\n                                         sum_coef += 4 * rows_n * cols_n;\n\n\n\n                        }\n/*\n                        ofstream dwt2out(\"dwt2out.dat\");\n                        for (unsigned int i= 0; i < dwt_output.size(); i++){\n                   dwt2out << dwt_output[i] <<endl;\n                        }\n                        */\n\n        return 0;\n\n}\n\n\n\nvoid* branch_lp_hp_up(string wname,vector<double> &cA, vector<double> &cD, vector<double> &X) {\n        vector<double> lpd1,hpd1, lpr1, hpr1;\n\n                filtcoef(wname,lpd1,hpd1,lpr1,hpr1);\n                int len_lpfilt = lpr1.size();\n                int len_hpfilt = hpr1.size();\n                int len_avg = (len_lpfilt + len_hpfilt) / 2;\n                //unsigned int N = 2 * cA.size();\n                int U = 2; // Upsampling Factor\n\n                // Operations in the Low Frequency branch of the Synthesis Filter Bank\n\n                vector<double> cA_up;\n                vector<double> X_lp;\n                per_ext(cA,len_avg/2);\n\n                upsamp(cA, U, cA_up);\n                convfftm(cA_up, lpr1, X_lp);\n\n\n                // Operations in the High Frequency branch of the Synthesis Filter Bank\n\n                vector<double> cD_up;\n                vector<double> X_hp;\n                per_ext(cD,len_avg/2);\n                upsamp(cD, U, cD_up);\n                convfftm(cD_up, hpr1, X_hp);\n\n\n\n\n                vecsum(X_lp,X_hp,X);\n           // Remove periodic extension\n\n                X.erase(X.begin(),X.begin()+len_avg+len_avg/2-1);\n                X.erase(X.end()-len_avg-len_avg/2,X.end());\n\n            return 0;\n}\n\nvoid* branch_hp_dn(string wname, vector<double> &signal, vector<double> &sigop) {\n\n        vector<double> lpd, hpd, lpr, hpr;\n\n                        filtcoef(wname,lpd,hpd,lpr,hpr);\n        //\t\tfor (unsigned int i = 0;  i < signal.size(); i++) {\n        //\t\tcout << signal[i] <<  endl;\n        //\t\tout2 << signal[i] <<endl;\n        //\t\t}\n\n                        unsigned int temp_len = signal.size();\n\n                        if ( (temp_len % 2) != 0) {\n                                double temp =signal[temp_len - 1];\n                                signal.push_back(temp);\n                        }\n\n                        int len_lpfilt = lpd.size();\n                        int len_hpfilt = hpd.size();\n                        int len_avg = (len_lpfilt + len_hpfilt) / 2;\n\n                        // cout << len_lpfilt << \"Filter\" << endl;\n                        per_ext(signal,len_avg / 2); // Periodic Extension\n                        // computations designed to deal with boundary distortions\n\n                        // Low Pass Filtering Operations in the Analysis Filter Bank Section\n        //\t\tint len_cA =(int)  floor(double (len_sig + len_lpfilt -1) / double (2));\n                        vector<double> cA_undec;\n                        // convolving signal with lpd, Low Pass Filter, and O/P is stored in cA_undec\n                        convfftm(signal,hpd,cA_undec);\n                        int D = 2; // Downsampling Factor is 2\n\n                        // Downsampling by 2 gives cA\n                        downsamp(cA_undec, D, sigop);\n\n                        sigop.erase(sigop.begin(),sigop.begin()+len_avg/2);\n                        sigop.erase(sigop.end()-len_avg/2,sigop.end());\nreturn 0;\n\n\n\n}\nvoid* branch_lp_dn(string wname, vector<double> &signal, vector<double> &sigop){\n\n        vector<double> lpd, hpd, lpr, hpr;\n\n                        filtcoef(wname,lpd,hpd,lpr,hpr);\n        //\t\tfor (unsigned int i = 0;  i < signal.size(); i++) {\n        //\t\tcout << signal[i] <<  endl;\n        //\t\tout2 << signal[i] <<endl;\n        //\t\t}\n\n                        unsigned int temp_len = signal.size();\n\n                        if ( (temp_len % 2) != 0) {\n                                double temp =signal[temp_len - 1];\n                                signal.push_back(temp);\n                        }\n\n                        int len_lpfilt = lpd.size();\n                        int len_hpfilt = hpd.size();\n                        int len_avg = (len_lpfilt + len_hpfilt) / 2;\n\n                        // cout << len_lpfilt << \"Filter\" << endl;\n                        per_ext(signal,len_avg / 2); // Periodic Extension\n                        // computations designed to deal with boundary distortions\n\n                        // Low Pass Filtering Operations in the Analysis Filter Bank Section\n        //\t\tint len_cA =(int)  floor(double (len_sig + len_lpfilt -1) / double (2));\n                        vector<double> cA_undec;\n                        // convolving signal with lpd, Low Pass Filter, and O/P is stored in cA_undec\n                        convfftm(signal,lpd,cA_undec);\n                        int D = 2; // Downsampling Factor is 2\n\n                        // Downsampling by 2 gives cA\n                        downsamp(cA_undec, D, sigop);\n\n                        sigop.erase(sigop.begin(),sigop.begin()+len_avg/2);\n                        sigop.erase(sigop.end()-len_avg/2,sigop.end());\n\n\nreturn 0;\n\n}\n\nvoid* idwt2(string name,vector<vector<double> > &signal, vector<vector<double> >  &cLL,\n                vector<vector<double> >  &cLH, vector<vector<double> >  &cHL, vector<vector<double> > &cHH) {\n// Synthesis\n        int rows= cLL.size();\n        int cols= cLL[0].size();\n        int rows_n = 2 * rows;\n        // Row Upsampling and Column Filtering at the first LP Stage\n        vector<vector<double> > cL(rows_n,vector<double>(cols));\n        vector<vector<double> > cH(rows_n,vector<double>(cols));\n\n    for (int j =0; j < cols; j++) {\n\n                vector<double> sigLL;\n                vector<double> sigLH;\n                for (int i=0;i <  rows;i++) {\n\n                        double temp1 = cLL[i][j];\n                        double temp2 = cLH[i][j];\n                        sigLL.push_back(temp1);\n                        sigLH.push_back(temp2);\n                }\n                        vector<double> oup;\n\n                        branch_lp_hp_up(name,sigLL,sigLH,oup);\n                        sigLL.clear();\n                        sigLH.clear();\n                        for (int i=0;i < (int) oup.size();i++) {\n                        cL[i][j] = oup[i];\n                        }\n\n        }\n\n    for (int j =0; j < cols; j++) {\n                vector<double> sigHL;\n                vector<double> sigHH;\n                for (int i=0;i <  rows;i++) {\n                        double temp3 = cHL[i][j];\n                        double temp4 = cHH[i][j];\n                        sigHL.push_back(temp3);\n                        sigHH.push_back(temp4);\n                }\n                        vector<double> oup2;\n                        branch_lp_hp_up(name,sigHL,sigHH,oup2);\n                        sigHL.clear();\n                        sigHH.clear();\n\n                        for (int i=0;i < (int) oup2.size();i++) {\n                        cH[i][j] = oup2[i];\n                        }\n\n        }\n\n    for (int i =0; i < rows_n; i++) {\n                vector<double> sigL;\n                vector<double> sigH;\n                for (int j=0;j <  cols;j++) {\n                        double temp5 = cL[i][j];\\\n                        double temp6 = cH[i][j];\n                        sigL.push_back(temp5);\n                        sigH.push_back(temp6);\n                }\n                        vector<double> oup3;\n                        branch_lp_hp_up(name,sigL,sigH,oup3);\n                        sigL.clear();\n                        sigH.clear();\n\n                        for (int j=0;j < (int) oup3.size();j++) {\n                        signal[i][j] = oup3[j];\n                        }\n\n        }\n        return 0;\n}\n\nvoid* dwt2(string name,vector<vector<double> > &signal, vector<vector<double> >  &cLL,\n                vector<vector<double> >  &cLH, vector<vector<double> >  &cHL, vector<vector<double> > &cHH){\n//Analysis\n    int rows = signal.size();\n    int cols = signal[0].size();\n    int cols_lp1 = cLL[0].size();\n    int cols_hp1 = cLL[0].size();\n    vector<double> lp1,hp1,lp2,hp2;\n    filtcoef(name, lp1,hp1,lp2,hp2);\n    vector<vector<double> > lp_dn1(rows, vector<double>( cols_lp1));\n    vector<vector<double> > hp_dn1(rows, vector<double>( cols_hp1));\n\n    // Implementing row filtering and column downsampling in each branch.\n    for (int i =0; i < rows; i++) {\n                vector<double> temp_row,oup_lp,oup_hp;\n                for (int j=0;j <  cols;j++) {\n                        double temp = signal[i][j];\n                        temp_row.push_back(temp);\n                }\n                dwt1_m(name,temp_row,oup_lp,oup_hp);\n\n                        for (int j=0;j < (int) oup_lp.size();j++) {\n                        lp_dn1[i][j] = oup_lp[j];\n                        hp_dn1[i][j] = oup_hp[j];\n\n                        }\n\n        }\n\n\n    cols =cols_lp1;\n    // Implementing column filtering and row downsampling in Low Pass branch.\n\n    for (int j =0; j < cols; j++) {\n                vector<double> temp_row3,oup_lp,oup_hp;\n                for (int i=0;i <  rows;i++) {\n                        double temp = lp_dn1[i][j];\n                        temp_row3.push_back(temp);\n                }\n                dwt1_m(name,temp_row3,oup_lp,oup_hp);\n\n                        for (int i=0;i < (int) oup_lp.size();i++) {\n                        cLL[i][j] = oup_lp[i];\n                        cLH[i][j] = oup_hp[i];\n\n                        }\n\n\n        }\n\n\n\n    // Implementing column filtering and row downsampling in High Pass branch.\n\n    for (int j =0; j < cols; j++) {\n                vector<double> temp_row5,oup_lp,oup_hp;\n                for (int i=0;i <  rows;i++) {\n                        double temp = hp_dn1[i][j];\n                        temp_row5.push_back(temp);\n                }\n                dwt1_m(name,temp_row5,oup_lp,oup_hp);\n\n                        for (int i=0;i < (int) oup_lp.size();i++) {\n                        cHL[i][j] = oup_lp[i];\n                        cHH[i][j] = oup_hp[i];\n\n                        }\n\n\n        }\n    return 0;\n}\n\n\nvoid* downsamp2(vector<vector<double> > & vec1,vector<vector<double> > & vec2, int rows_dn, int cols_dn) {\n\n        int rows = vec1.size();\n        int cols = vec1[0].size();\n        double rows_n = ceil( (double) rows / (double) rows_dn);\n        double cols_n = ceil( (double) cols / (double) cols_dn);\n        for (int i =0; i < (int)rows_n; i++){\n                for (int j = 0; j< (int) cols_n; j++){\n\n  vec2[i][j] = vec1[i * rows_dn][j*cols_dn];\n                }\n        }\n\n        return 0;\n}\n\nvoid* upsamp2(vector<vector<double> > & vec1,vector<vector<double> > & vec2, int rows_up, int cols_up){\n\n        int rows = vec1.size();\n        int cols = vec1[0].size();\n        int rows_n = rows *  rows_up;\n        int cols_n =  cols *  cols_up;\n        for (int i = 0; i < rows_n; i++){\n                for (int j = 0; j < cols_n; j++){\n                        if ( i % rows_up == 0 && j % cols_up == 0){\n         vec2[i][j]=vec1[(int) (i/rows_up)][(int) (j/cols_up)];\n        } else {\n         vec2[i][j] = 0;\n        }\n}\n}\n return 0;\n}\n\n\nint filtcoef(string name, vector<double> &lp1, vector<double> &hp1, vector<double> &lp2,\n                vector<double> &hp2){\n    if (name == \"haar\" || name == \"db1\" ) {\n        lp1.push_back(0.7071);lp1.push_back(0.7071);\n        hp1.push_back(-0.7071);hp1.push_back(0.7071);\n        lp2.push_back(0.7071);lp2.push_back(0.7071);\n        hp2.push_back(0.7071);hp2.push_back(-0.7071);\n  //  \tcout << lp2[1] << endl;\n//    \thpd = {-0.7071, 0.7071};\n//    \tlpr = {0.7071, 0.7071};\n//    \thpr = {0.7071, -0.7071};\n     return 0;\n    }\n    else if ( name == \"db2\"){\n        double lp1_a[] = {-0.12940952255092145, 0.22414386804185735, 0.83651630373746899,\n                        0.48296291314469025};\n        lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n        double hp1_a[] = {-0.48296291314469025, 0.83651630373746899, -0.22414386804185735,\n                        -0.12940952255092145};\n         hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n        double lp2_a[] = {0.48296291314469025, 0.83651630373746899, 0.22414386804185735,\n                        -0.12940952255092145};\n         lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n         double hp2_a[] = {-0.12940952255092145, -0.22414386804185735, 0.83651630373746899,\n                         -0.48296291314469025};\n         hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n         return 0;\n    }\n\n    else if ( name == \"db3\"){\n        double lp1_a[] = {0.035226291882100656, -0.085441273882241486, -0.13501102001039084,\n                        0.45987750211933132, 0.80689150931333875, 0.33267055295095688};\n        lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n        double hp1_a[] = {-0.33267055295095688, 0.80689150931333875, -0.45987750211933132,\n                        -0.13501102001039084, 0.085441273882241486, 0.035226291882100656 };\n         hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n        double lp2_a[] = {0.33267055295095688, 0.80689150931333875, 0.45987750211933132,\n                        -0.13501102001039084, -0.085441273882241486, 0.035226291882100656 };\n         lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n         double hp2_a[] = {0.035226291882100656, 0.085441273882241486, -0.13501102001039084,\n                         -0.45987750211933132, 0.80689150931333875, -0.33267055295095688 };\n         hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n         return 0;\n    }\n\n    else if ( name == \"db4\"){\n        double lp1_a[] = {-0.010597401784997278, 0.032883011666982945, 0.030841381835986965,\n                        -0.18703481171888114, -0.027983769416983849, 0.63088076792959036,\n                        0.71484657055254153, 0.23037781330885523 };\n        lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n        double hp1_a[] = {-0.23037781330885523, 0.71484657055254153, -0.63088076792959036,\n                        -0.027983769416983849, 0.18703481171888114, 0.030841381835986965,\n                        -0.032883011666982945, -0.010597401784997278 };\n         hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n        double lp2_a[] = {0.23037781330885523, 0.71484657055254153, 0.63088076792959036,\n                        -0.027983769416983849, -0.18703481171888114, 0.030841381835986965,\n                        0.032883011666982945, -0.010597401784997278 };\n         lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n         double hp2_a[] = {-0.010597401784997278, -0.032883011666982945, 0.030841381835986965,\n                         0.18703481171888114, -0.027983769416983849, -0.63088076792959036,\n                         0.71484657055254153, -0.23037781330885523 };\n         hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n         return 0;\n    }\n\n    else if ( name == \"db5\"){\n        double lp1_a[] = {0.0033357252850015492, -0.012580751999015526, -0.0062414902130117052,\n                        0.077571493840065148, -0.03224486958502952, -0.24229488706619015,\n                        0.13842814590110342, 0.72430852843857441, 0.60382926979747287,\n                0.16010239797412501 };\n        lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n        double hp1_a[] = {-0.16010239797412501, 0.60382926979747287, -0.72430852843857441,\n                        0.13842814590110342, 0.24229488706619015, -0.03224486958502952,\n                        -0.077571493840065148, -0.0062414902130117052, 0.012580751999015526,\n                        0.0033357252850015492 };\n         hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n        double lp2_a[] = {0.16010239797412501, 0.60382926979747287, 0.72430852843857441,\n                        0.13842814590110342, -0.24229488706619015, -0.03224486958502952,\n                        0.077571493840065148, -0.0062414902130117052, -0.012580751999015526,\n                        0.0033357252850015492 };\n         lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n         double hp2_a[] = {0.0033357252850015492, 0.012580751999015526, -0.0062414902130117052,\n                         -0.077571493840065148, -0.03224486958502952, 0.24229488706619015,\n                         0.13842814590110342, -0.72430852843857441, 0.60382926979747287,\n                         -0.16010239797412501 };\n         hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n         return 0;\n    }\n\n    else if ( name == \"db6\"){\n        double lp1_a[] = {-0.0010773010849955799,\n                        0.0047772575110106514,\n                        0.0005538422009938016,\n                        -0.031582039318031156,\n                        0.027522865530016288,\n                        0.097501605587079362,\n                        -0.12976686756709563,\n                        -0.22626469396516913,\n                        0.3152503517092432,\n                        0.75113390802157753,\n                        0.49462389039838539,\n                        0.11154074335008017\n};\n        lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n        double hp1_a[] = {-0.11154074335008017,\n                        0.49462389039838539,\n                        -0.75113390802157753,\n                        0.3152503517092432,\n                        0.22626469396516913,\n                        -0.12976686756709563,\n                        -0.097501605587079362,\n                        0.027522865530016288,\n                        0.031582039318031156,\n                        0.0005538422009938016,\n                        -0.0047772575110106514,\n                        -0.0010773010849955799\n};\n         hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n        double lp2_a[] = {0.11154074335008017,\n                        0.49462389039838539,\n                        0.75113390802157753,\n                        0.3152503517092432,\n                        -0.22626469396516913,\n                        -0.12976686756709563,\n                        0.097501605587079362,\n                        0.027522865530016288,\n                        -0.031582039318031156,\n                        0.0005538422009938016,\n                        0.0047772575110106514,\n                        -0.0010773010849955799\n};\n         lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n         double hp2_a[] = {-0.0010773010849955799,\n                         -0.0047772575110106514,\n                         0.0005538422009938016,\n                         0.031582039318031156,\n                         0.027522865530016288,\n                         -0.097501605587079362,\n                         -0.12976686756709563,\n                         0.22626469396516913,\n                         0.3152503517092432,\n                         -0.75113390802157753,\n                         0.49462389039838539,\n                         -0.11154074335008017\n};\n         hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n         return 0;\n    }\n\n    else if ( name == \"db7\"){\n                double lp1_a[] = {0.00035371380000103988,\n                                -0.0018016407039998328,\n                                0.00042957797300470274,\n                                0.012550998556013784,\n                                -0.01657454163101562,\n                                -0.038029936935034633,\n                                0.080612609151065898,\n                                0.071309219267050042,\n                                -0.22403618499416572,\n                                -0.14390600392910627,\n                                0.4697822874053586,\n                                0.72913209084655506,\n                                0.39653931948230575,\n                                0.077852054085062364\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.077852054085062364,\n                                0.39653931948230575,\n                                -0.72913209084655506,\n                                0.4697822874053586,\n                                0.14390600392910627,\n                                -0.22403618499416572,\n                                -0.071309219267050042,\n                                0.080612609151065898,\n                                0.038029936935034633,\n                                -0.01657454163101562,\n                                -0.012550998556013784,\n                                0.0004295779730047027,\n                                0.0018016407039998328,\n                                0.00035371380000103988\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.077852054085062364,\n                                0.39653931948230575,\n                                0.72913209084655506,\n                                0.4697822874053586,\n                                -0.14390600392910627,\n                                -0.22403618499416572,\n                                0.071309219267050042,\n                                0.080612609151065898,\n                                -0.038029936935034633,\n                                -0.01657454163101562,\n                                0.012550998556013784,\n                                0.00042957797300470274,\n                                -0.0018016407039998328,\n                                0.00035371380000103988\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.00035371380000103988,\n                                 0.0018016407039998328,\n                                 0.00042957797300470274,\n                                 -0.01255099855601378,\n                                 -0.01657454163101562,\n                                 0.038029936935034633,\n                                 0.080612609151065898,\n                                 -0.071309219267050042,\n                                 -0.22403618499416572,\n                                 0.14390600392910627,\n                                 0.4697822874053586,\n                                 -0.72913209084655506,\n                                 0.39653931948230575,\n                                 -0.077852054085062364\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"db8\"){\n                double lp1_a[] = {-0.00011747678400228192,\n                                0.00067544940599855677,\n                                -0.00039174037299597711,\n                                -0.0048703529930106603,\n                                0.0087460940470156547,\n                                0.013981027917015516,\n                                -0.044088253931064719,\n                                -0.017369301002022108,\n                                0.12874742662018601,\n                                0.00047248457399797254,\n                                -0.28401554296242809,\n                                -0.015829105256023893,\n                                0.58535468365486909,\n                                0.67563073629801285,\n                                0.31287159091446592,\n                                0.054415842243081609\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.054415842243081609,\n                                0.31287159091446592,\n                                -0.67563073629801285,\n                                0.58535468365486909,\n                                0.015829105256023893,\n                                -0.28401554296242809,\n                                -0.00047248457399797254,\n                                0.12874742662018601,\n                                0.017369301002022108,\n                                -0.044088253931064719,\n                                -0.013981027917015516,\n                                0.0087460940470156547,\n                                0.0048703529930106603,\n                                -0.00039174037299597711,\n                                -0.00067544940599855677,\n                                -0.00011747678400228192\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.054415842243081609,\n                                0.31287159091446592,\n                                0.67563073629801285,\n                                0.58535468365486909,\n                                -0.015829105256023893,\n                                -0.28401554296242809,\n                                0.00047248457399797254,\n                                0.12874742662018601,\n                                -0.017369301002022108,\n                                -0.044088253931064719,\n                                0.013981027917015516,\n                                0.0087460940470156547,\n                                -0.0048703529930106603,\n                                -0.00039174037299597711,\n                                0.00067544940599855677,\n                                -0.00011747678400228192\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.00011747678400228192,\n                                 -0.00067544940599855677,\n                                 -0.00039174037299597711,\n                                 0.0048703529930106603,\n                                 0.0087460940470156547,\n                                 -0.013981027917015516,\n                                 -0.044088253931064719,\n                                 0.017369301002022108,\n                                 0.12874742662018601,\n                                 -0.00047248457399797254,\n                                 -0.28401554296242809,\n                                 0.015829105256023893,\n                                 0.58535468365486909,\n                                 -0.67563073629801285,\n                                 0.31287159091446592,\n                                 -0.054415842243081609\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"db9\"){\n                double lp1_a[] = {3.9347319995026124e-05,\n                                -0.00025196318899817888,\n                                0.00023038576399541288,\n                                0.0018476468829611268,\n                                -0.0042815036819047227,\n                                -0.004723204757894831,\n                                0.022361662123515244,\n                                0.00025094711499193845,\n                                -0.067632829059523988,\n                                0.030725681478322865,\n                                0.14854074933476008,\n                                -0.096840783220879037,\n                                -0.29327378327258685,\n                                0.13319738582208895,\n                                0.65728807803663891,\n                                0.6048231236767786,\n                                0.24383467463766728,\n                                0.038077947363167282\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.038077947363167282,\n                                0.24383467463766728,\n                                -0.6048231236767786,\n                                0.65728807803663891,\n                                -0.13319738582208895,\n                                -0.29327378327258685,\n                                0.096840783220879037,\n                                0.14854074933476008,\n                                -0.030725681478322865,\n                                -0.067632829059523988,\n                                -0.00025094711499193845,\n                                0.022361662123515244,\n                                0.004723204757894831,\n                                -0.0042815036819047227,\n                                -0.0018476468829611268,\n                                0.00023038576399541288,\n                                0.00025196318899817888,\n                                3.9347319995026124e-05\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.038077947363167282,\n                                0.24383467463766728,\n                                0.6048231236767786,\n                                0.65728807803663891,\n                                0.13319738582208895,\n                                -0.29327378327258685,\n                                -0.096840783220879037,\n                                0.14854074933476008,\n                                0.030725681478322865,\n                                -0.067632829059523988,\n                                0.00025094711499193845,\n                                0.022361662123515244,\n                                -0.004723204757894831,\n                                -0.0042815036819047227,\n                                0.0018476468829611268,\n                                0.00023038576399541288,\n                                -0.00025196318899817888,\n                                3.9347319995026124e-05\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {3.9347319995026124e-05,\n                                 0.00025196318899817888,\n                                 0.00023038576399541288,\n                                 -0.0018476468829611268,\n                                 -0.0042815036819047227,\n                                 0.004723204757894831,\n                                 0.022361662123515244,\n                                 -0.00025094711499193845,\n                                 -0.067632829059523988,\n                                 -0.030725681478322865,\n                                 0.14854074933476008,\n                                 0.096840783220879037,\n                                 -0.29327378327258685,\n                                 -0.13319738582208895,\n                                 0.65728807803663891,\n                                 -0.6048231236767786,\n                                 0.24383467463766728,\n                                 -0.038077947363167282\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"db10\"){\n                double lp1_a[] = {-1.3264203002354869e-05,\n                                9.3588670001089845e-05,\n                                -0.0001164668549943862,\n                                -0.00068585669500468248,\n                                0.0019924052949908499,\n                                0.0013953517469940798,\n                                -0.010733175482979604,\n                                0.0036065535669883944,\n                                0.033212674058933238,\n                                -0.029457536821945671,\n                                -0.071394147165860775,\n                                0.093057364603806592,\n                                0.12736934033574265,\n                                -0.19594627437659665,\n                                -0.24984642432648865,\n                                0.28117234366042648,\n                                0.68845903945259213,\n                                0.52720118893091983,\n                                0.18817680007762133,\n                                0.026670057900950818\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.026670057900950818,\n                                0.18817680007762133,\n                                -0.52720118893091983,\n                                0.68845903945259213,\n                                -0.28117234366042648,\n                                -0.24984642432648865,\n                                0.19594627437659665,\n                                0.12736934033574265,\n                                -0.093057364603806592,\n                                -0.071394147165860775,\n                                0.029457536821945671,\n                                0.033212674058933238,\n                                -0.0036065535669883944,\n                                -0.010733175482979604,\n                                -0.0013953517469940798,\n                                0.0019924052949908499,\n                                0.00068585669500468248,\n                                -0.0001164668549943862,\n                                -9.3588670001089845e-05,\n                                -1.3264203002354869e-05\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.026670057900950818,\n                                0.18817680007762133,\n                                0.52720118893091983,\n                                0.68845903945259213,\n                                0.28117234366042648,\n                                -0.24984642432648865,\n                                -0.19594627437659665,\n                                0.12736934033574265,\n                                0.093057364603806592,\n                                -0.071394147165860775,\n                                -0.029457536821945671,\n                                0.033212674058933238,\n                                0.0036065535669883944,\n                                -0.010733175482979604,\n                                0.0013953517469940798,\n                                0.0019924052949908499,\n                                -0.00068585669500468248,\n                                -0.0001164668549943862,\n                                9.3588670001089845e-05,\n                                -1.3264203002354869e-05\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-1.3264203002354869e-05,\n                                 -9.3588670001089845e-05,\n                                 -0.0001164668549943862,\n                                 0.00068585669500468248,\n                                 0.0019924052949908499,\n                                 -0.0013953517469940798,\n                                 -0.010733175482979604,\n                                 -0.0036065535669883944,\n                                 0.033212674058933238,\n                                 0.029457536821945671,\n                                 -0.071394147165860775,\n                                 -0.093057364603806592,\n                                 0.12736934033574265,\n                                 0.19594627437659665,\n                                 -0.24984642432648865,\n                                 -0.28117234366042648,\n                                 0.68845903945259213,\n                                 -0.52720118893091983,\n                                 0.18817680007762133,\n                                 -0.026670057900950818\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"db12\"){\n                double lp1_a[] = {-1.5290717580684923e-06,\n                                1.2776952219379579e-05,\n                                -2.4241545757030318e-05,\n                                -8.8504109208203182e-05,\n                                0.00038865306282092672,\n                                6.5451282125215034e-06,\n                                -0.0021795036186277044,\n                                0.0022486072409952287,\n                                0.0067114990087955486,\n                                -0.012840825198299882,\n                                -0.01221864906974642,\n                                0.041546277495087637,\n                                0.010849130255828966,\n                                -0.09643212009649671,\n                                0.0053595696743599965,\n                                0.18247860592758275,\n                                -0.023779257256064865,\n                                -0.31617845375277914,\n                                -0.044763885653777619,\n                                0.51588647842780067,\n                                0.65719872257929113,\n                                0.37735513521420411,\n                                0.10956627282118277,\n                                0.013112257957229239\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.013112257957229239,\n                                0.10956627282118277,\n                                -0.37735513521420411,\n                                0.65719872257929113,\n                                -0.51588647842780067,\n                                -0.044763885653777619,\n                                0.31617845375277914,\n                                -0.023779257256064865,\n                                -0.18247860592758275,\n                                0.0053595696743599965,\n                                0.09643212009649671,\n                                0.010849130255828966,\n                                -0.041546277495087637,\n                                -0.01221864906974642,\n                                0.012840825198299882,\n                                0.0067114990087955486,\n                                -0.0022486072409952287,\n                                -0.0021795036186277044,\n                                -6.5451282125215034e-06,\n                                0.00038865306282092672,\n                                8.8504109208203182e-05,\n                                -2.4241545757030318e-05,\n                                -1.2776952219379579e-05,\n                                -1.5290717580684923e-06\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.013112257957229239,\n                                0.10956627282118277,\n                                0.37735513521420411,\n                                0.65719872257929113,\n                                0.51588647842780067,\n                                -0.044763885653777619,\n                                -0.31617845375277914,\n                                -0.023779257256064865,\n                                0.18247860592758275,\n                                0.0053595696743599965,\n                                -0.09643212009649671,\n                                0.010849130255828966,\n                                0.041546277495087637,\n                                -0.01221864906974642,\n                                -0.012840825198299882,\n                                0.0067114990087955486,\n                                0.0022486072409952287,\n                                -0.0021795036186277044,\n                                6.5451282125215034e-06,\n                                0.00038865306282092672,\n                                -8.8504109208203182e-05,\n                                -2.4241545757030318e-05,\n                                1.2776952219379579e-05,\n                                -1.5290717580684923e-06\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-1.5290717580684923e-06,\n                                 -1.2776952219379579e-05,\n                                 -2.4241545757030318e-05,\n                                 8.8504109208203182e-05,\n                                 0.00038865306282092672,\n                                 -6.5451282125215034e-06,\n                                 -0.0021795036186277044,\n                                 -0.0022486072409952287,\n                                 0.0067114990087955486,\n                                 0.012840825198299882,\n                                 -0.01221864906974642,\n                                 -0.041546277495087637,\n                                 0.010849130255828966,\n                                 0.09643212009649671,\n                                 0.0053595696743599965,\n                                 -0.18247860592758275,\n                                 -0.023779257256064865,\n                                 0.31617845375277914,\n                                 -0.044763885653777619,\n                                 -0.51588647842780067,\n                                 0.65719872257929113,\n                                 -0.37735513521420411,\n                                 0.10956627282118277,\n                                 -0.013112257957229239\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"db13\"){\n                double lp1_a[] = {5.2200350984547998e-07,\n                                -4.7004164793608082e-06,\n                                1.0441930571407941e-05,\n                                3.0678537579324358e-05,\n                                -0.00016512898855650571,\n                                4.9251525126285676e-05,\n                                0.00093232613086724904,\n                                -0.0013156739118922766,\n                                -0.002761911234656831,\n                                0.0072555894016171187,\n                                0.0039239414487955773,\n                                -0.023831420710327809,\n                                0.0023799722540522269,\n                                0.056139477100276156,\n                                -0.026488406475345658,\n                                -0.10580761818792761,\n                                0.072948933656788742,\n                                0.17947607942935084,\n                                -0.12457673075080665,\n                                -0.31497290771138414,\n                                0.086985726179645007,\n                                0.58888957043121193,\n                                0.61105585115878114,\n                                0.31199632216043488,\n                                0.082861243872901946,\n                                0.0092021335389622788\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.0092021335389622788,\n                                0.082861243872901946,\n                                -0.31199632216043488,\n                                0.61105585115878114,\n                                -0.58888957043121193,\n                                0.086985726179645007,\n                                0.31497290771138414,\n                                -0.12457673075080665,\n                                -0.17947607942935084,\n                                0.072948933656788742,\n                                0.10580761818792761,\n                                -0.026488406475345658,\n                                -0.056139477100276156,\n                                0.0023799722540522269,\n                                0.023831420710327809,\n                                0.0039239414487955773,\n                                -0.0072555894016171187,\n                                -0.002761911234656831,\n                                0.0013156739118922766,\n                                0.00093232613086724904,\n                                -4.9251525126285676e-05,\n                                -0.00016512898855650571,\n                                -3.0678537579324358e-05,\n                                1.0441930571407941e-05,\n                                4.7004164793608082e-06,\n                                5.2200350984547998e-07\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0092021335389622788,\n                                0.082861243872901946,\n                                0.31199632216043488,\n                                0.61105585115878114,\n                                0.58888957043121193,\n                                0.086985726179645007,\n                                -0.31497290771138414,\n                                -0.12457673075080665,\n                                0.17947607942935084,\n                                0.072948933656788742,\n                                -0.10580761818792761,\n                                -0.026488406475345658,\n                                0.056139477100276156,\n                                0.0023799722540522269,\n                                -0.023831420710327809,\n                                0.0039239414487955773,\n                                0.0072555894016171187,\n                                -0.002761911234656831,\n                                -0.0013156739118922766,\n                                0.00093232613086724904,\n                                4.9251525126285676e-05,\n                                -0.00016512898855650571,\n                                3.0678537579324358e-05,\n                                1.0441930571407941e-05,\n                                -4.7004164793608082e-06,\n                                5.2200350984547998e-07\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {5.2200350984547998e-07,\n                                 4.7004164793608082e-06,\n                                 1.0441930571407941e-05,\n                                 -3.0678537579324358e-05,\n                                 -0.00016512898855650571,\n                                 -4.9251525126285676e-05,\n                                 0.00093232613086724904,\n                                 0.0013156739118922766,\n                                 -0.002761911234656831,\n                                 -0.0072555894016171187,\n                                 0.0039239414487955773,\n                                 0.023831420710327809,\n                                 0.0023799722540522269,\n                                 -0.056139477100276156,\n                                 -0.026488406475345658,\n                                 0.10580761818792761,\n                                 0.072948933656788742,\n                                 -0.17947607942935084,\n                                 -0.12457673075080665,\n                                 0.31497290771138414,\n                                 0.086985726179645007,\n                                 -0.58888957043121193,\n                                 0.61105585115878114,\n                                 -0.31199632216043488,\n                                 0.082861243872901946,\n                                 -0.0092021335389622788\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n\n    else if ( name == \"db11\"){\n                double lp1_a[] = {4.4942742772363519e-06,\n                                -3.4634984186983789e-05,\n                                5.4439074699366381e-05,\n                                0.00024915252355281426,\n                                -0.00089302325066623663,\n                                -0.00030859285881515924,\n                                0.0049284176560587777,\n                                -0.0033408588730145018,\n                                -0.015364820906201324,\n                                0.020840904360180039,\n                                0.031335090219045313,\n                                -0.066438785695020222,\n                                -0.04647995511667613,\n                                0.14981201246638268,\n                                0.066043588196690886,\n                                -0.27423084681792875,\n                                -0.16227524502747828,\n                                0.41196436894789695,\n                                0.68568677491617847,\n                                0.44989976435603013,\n                                0.14406702115061959,\n                                0.018694297761470441\n  };\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.018694297761470441,\n                                0.14406702115061959,\n                                -0.44989976435603013,\n                                0.68568677491617847,\n                                -0.41196436894789695,\n                                -0.16227524502747828,\n                                0.27423084681792875,\n                                0.066043588196690886,\n                                -0.14981201246638268,\n                                -0.04647995511667613,\n                                0.066438785695020222,\n                                0.031335090219045313,\n                                -0.020840904360180039,\n                                -0.015364820906201324,\n                                0.0033408588730145018,\n                                0.0049284176560587777,\n                                0.00030859285881515924,\n                                -0.00089302325066623663,\n                                -0.00024915252355281426,\n                                5.4439074699366381e-05,\n                                3.4634984186983789e-05,\n                                4.4942742772363519e-06\n  };\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.018694297761470441,\n                                0.14406702115061959,\n                                0.44989976435603013,\n                                0.68568677491617847,\n                                0.41196436894789695,\n                                -0.16227524502747828,\n                                -0.27423084681792875,\n                                0.066043588196690886,\n                                0.14981201246638268,\n                                -0.04647995511667613,\n                                -0.066438785695020222,\n                                0.031335090219045313,\n                                0.020840904360180039,\n                                -0.015364820906201324,\n                                -0.0033408588730145018,\n                                0.0049284176560587777,\n                                -0.00030859285881515924,\n                                -0.00089302325066623663,\n                                0.00024915252355281426,\n                                5.4439074699366381e-05,\n                                -3.4634984186983789e-05,\n                                4.4942742772363519e-06\n  };\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {4.4942742772363519e-06,\n                                 3.4634984186983789e-05,\n                                 5.4439074699366381e-05,\n                                 -0.00024915252355281426,\n                                 -0.00089302325066623663,\n                                 0.00030859285881515924,\n                                 0.0049284176560587777,\n                                 0.0033408588730145018,\n                                 -0.015364820906201324,\n                                 -0.020840904360180039,\n                                 0.031335090219045313,\n                                 0.066438785695020222,\n                                 -0.04647995511667613,\n                                 -0.14981201246638268,\n                                 0.066043588196690886,\n                                 0.27423084681792875,\n                                 -0.16227524502747828,\n                                 -0.41196436894789695,\n                                 0.68568677491617847,\n                                 -0.44989976435603013,\n                                 0.14406702115061959,\n                                 -0.018694297761470441\n  };\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n              }\n\n    else if ( name == \"db14\"){\n                        double lp1_a[] = {-1.7871399683109222e-07,\n                                        1.7249946753674012e-06,\n                                        -4.3897049017804176e-06,\n                                        -1.0337209184568496e-05,\n                                        6.875504252695734e-05,\n                                        -4.1777245770370672e-05,\n                                        -0.00038683194731287514,\n                                        0.00070802115423540481,\n                                        0.001061691085606874,\n                                        -0.003849638868019787,\n                                        -0.00074621898926387534,\n                                        0.012789493266340071,\n                                        -0.0056150495303375755,\n                                        -0.030185351540353976,\n                                        0.026981408307947971,\n                                        0.05523712625925082,\n                                        -0.071548955503983505,\n                                        -0.086748411568110598,\n                                        0.13998901658445695,\n                                        0.13839521386479153,\n                                        -0.21803352999321651,\n                                        -0.27168855227867705,\n                                        0.21867068775886594,\n                                        0.63118784910471981,\n                                        0.55430561794077093,\n                                        0.25485026779256437,\n                                        0.062364758849384874,\n                                        0.0064611534600864905\n};\n                        lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                        double hp1_a[] = {-0.0064611534600864905,\n                                        0.062364758849384874,\n                                        -0.25485026779256437,\n                                        0.55430561794077093,\n                                        -0.63118784910471981,\n                                        0.21867068775886594,\n                                        0.27168855227867705,\n                                        -0.21803352999321651,\n                                        -0.13839521386479153,\n                                        0.13998901658445695,\n                                        0.086748411568110598,\n                                        -0.071548955503983505,\n                                        -0.05523712625925082,\n                                        0.026981408307947971,\n                                        0.030185351540353976,\n                                        -0.0056150495303375755,\n                                        -0.012789493266340071,\n                                        -0.00074621898926387534,\n                                        0.003849638868019787,\n                                        0.001061691085606874,\n                                        -0.00070802115423540481,\n                                        -0.00038683194731287514,\n                                        4.1777245770370672e-05,\n                                        6.875504252695734e-05,\n                                        1.0337209184568496e-05,\n                                        -4.3897049017804176e-06,\n                                        -1.7249946753674012e-06,\n                                        -1.7871399683109222e-07\n};\n                         hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                        double lp2_a[] = {0.0064611534600864905,\n                                        0.062364758849384874,\n                                        0.25485026779256437,\n                                        0.55430561794077093,\n                                        0.63118784910471981,\n                                        0.21867068775886594,\n                                        -0.27168855227867705,\n                                        -0.21803352999321651,\n                                        0.13839521386479153,\n                                        0.13998901658445695,\n                                        -0.086748411568110598,\n                                        -0.071548955503983505,\n                                        0.05523712625925082,\n                                        0.026981408307947971,\n                                        -0.030185351540353976,\n                                        -0.0056150495303375755,\n                                        0.012789493266340071,\n                                        -0.00074621898926387534,\n                                        -0.003849638868019787,\n                                        0.001061691085606874,\n                                        0.00070802115423540481,\n                                        -0.00038683194731287514,\n                                        -4.1777245770370672e-05,\n                                        6.875504252695734e-05,\n                                        -1.0337209184568496e-05,\n                                        -4.3897049017804176e-06,\n                                        1.7249946753674012e-06,\n                                        -1.7871399683109222e-07\n};\n                         lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                         double hp2_a[] = {-1.7871399683109222e-07,\n                                        -1.7249946753674012e-06,\n                                        -4.3897049017804176e-06,\n                                        1.0337209184568496e-05,\n                                        6.875504252695734e-05,\n                                        4.1777245770370672e-05,\n                                        -0.00038683194731287514,\n                                        -0.00070802115423540481,\n                                        0.001061691085606874,\n                                        0.003849638868019787,\n                                        -0.00074621898926387534,\n                                        -0.012789493266340071,\n                                        -0.0056150495303375755,\n                                        0.030185351540353976,\n                                        0.026981408307947971,\n                                        -0.05523712625925082,\n                                        -0.071548955503983505,\n                                        0.086748411568110598,\n                                        0.13998901658445695,\n                                        -0.13839521386479153,\n                                        -0.21803352999321651,\n                                        0.27168855227867705,\n                                        0.21867068775886594,\n                                        -0.63118784910471981,\n                                        0.55430561794077093,\n                                        -0.25485026779256437,\n                                        0.062364758849384874,\n                                        -0.0064611534600864905\n};\n                         hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                         return 0;\n                  }\n    else if ( name == \"db15\"){\n                double lp1_a[] = {6.1333599133037138e-08,\n                                -6.3168823258794506e-07,\n                                1.8112704079399406e-06,\n                                3.3629871817363823e-06,\n                                -2.8133296266037558e-05,\n                                2.579269915531323e-05,\n                                0.00015589648992055726,\n                                -0.00035956524436229364,\n                                -0.00037348235413726472,\n                                0.0019433239803823459,\n                                -0.00024175649075894543,\n                                -0.0064877345603061454,\n                                0.0051010003604228726,\n                                0.015083918027862582,\n                                -0.020810050169636805,\n                                -0.025767007328366939,\n                                0.054780550584559995,\n                                0.033877143923563204,\n                                -0.11112093603713753,\n                                -0.039666176555733602,\n                                0.19014671400708816,\n                                0.065282952848765688,\n                                -0.28888259656686216,\n                                -0.19320413960907623,\n                                0.33900253545462167,\n                                0.64581314035721027,\n                                0.49263177170797529,\n                                0.20602386398692688,\n                                0.046743394892750617,\n                                0.0045385373615773762\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.0045385373615773762,\n                                0.046743394892750617,\n                                -0.20602386398692688,\n                                0.49263177170797529,\n                                -0.64581314035721027,\n                                0.33900253545462167,\n                                0.19320413960907623,\n                                -0.28888259656686216,\n                                -0.065282952848765688,\n                                0.19014671400708816,\n                                0.039666176555733602,\n                                -0.11112093603713753,\n                                -0.033877143923563204,\n                                0.054780550584559995,\n                                0.025767007328366939,\n                                -0.020810050169636805,\n                                -0.015083918027862582,\n                                0.0051010003604228726,\n                                0.0064877345603061454,\n                                -0.00024175649075894543,\n                                -0.0019433239803823459,\n                                -0.00037348235413726472,\n                                0.00035956524436229364,\n                                0.00015589648992055726,\n                                -2.579269915531323e-05,\n                                -2.8133296266037558e-05,\n                                -3.3629871817363823e-06,\n                                1.8112704079399406e-06,\n                                6.3168823258794506e-07,\n                                6.1333599133037138e-08\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0045385373615773762,\n                                0.046743394892750617,\n                                0.20602386398692688,\n                                0.49263177170797529,\n                                0.64581314035721027,\n                                0.33900253545462167,\n                                -0.19320413960907623,\n                                -0.28888259656686216,\n                                0.065282952848765688,\n                                0.19014671400708816,\n                                -0.039666176555733602,\n                                -0.11112093603713753,\n                                0.033877143923563204,\n                                0.054780550584559995,\n                                -0.025767007328366939,\n                                -0.020810050169636805,\n                                0.015083918027862582,\n                                0.0051010003604228726,\n                                -0.0064877345603061454,\n                                -0.00024175649075894543,\n                                0.0019433239803823459,\n                                -0.00037348235413726472,\n                                -0.00035956524436229364,\n                                0.00015589648992055726,\n                                2.579269915531323e-05,\n                                -2.8133296266037558e-05,\n                                3.3629871817363823e-06,\n                                1.8112704079399406e-06,\n                                -6.3168823258794506e-07,\n                                6.1333599133037138e-08\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {6.1333599133037138e-08,\n                                 6.3168823258794506e-07,\n                                 1.8112704079399406e-06,\n                                 -3.3629871817363823e-06,\n                                 -2.8133296266037558e-05,\n                                 -2.579269915531323e-05,\n                                 0.00015589648992055726,\n                                 0.00035956524436229364,\n                                 -0.00037348235413726472,\n                                 -0.0019433239803823459,\n                                 -0.00024175649075894543,\n                                 0.0064877345603061454,\n                                 0.0051010003604228726,\n                                 -0.015083918027862582,\n                                 -0.020810050169636805,\n                                 0.025767007328366939,\n                                 0.054780550584559995,\n                                 -0.033877143923563204,\n                                 -0.11112093603713753,\n                                 0.039666176555733602,\n                                 0.19014671400708816,\n                                 -0.065282952848765688,\n                                 -0.28888259656686216,\n                                 0.19320413960907623,\n                                 0.33900253545462167,\n                                 -0.64581314035721027,\n                                 0.49263177170797529,\n                                 -0.20602386398692688,\n                                 0.046743394892750617,\n                                 -0.0045385373615773762\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior1.1\"){\n                double lp1_a[] = {0.70710678118654757,\n                                0.70710678118654757\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.70710678118654757,\n                                0.70710678118654757\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.70710678118654757,\n                                0.70710678118654757\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.70710678118654757,\n                                 -0.70710678118654757\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"bior1.3\"){\n                double lp1_a[] = {-0.088388347648318447,\n                                0.088388347648318447,\n                                0.70710678118654757,\n                                0.70710678118654757,\n                                0.088388347648318447,\n                                -0.088388347648318447,\n    };\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                -0.70710678118654757,\n                                0.70710678118654757,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                 0.0,\n                                 0.70710678118654757,\n                                 0.70710678118654757,\n                                 0.0,\n                                 0.0\n    };\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.088388347648318447,\n                                 -0.088388347648318447,\n                                 0.70710678118654757,\n                                 -0.70710678118654757,\n                                 0.088388347648318447,\n                                 0.088388347648318447\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n\n    else if ( name == \"bior1.5\"){\n                double lp1_a[] = {0.01657281518405971,\n                                -0.01657281518405971,\n                                -0.12153397801643787,\n                                0.12153397801643787,\n                                0.70710678118654757,\n                                0.70710678118654757,\n                                0.12153397801643787,\n                                -0.12153397801643787,\n                                -0.01657281518405971,\n                                0.01657281518405971\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                -0.70710678118654757,\n                                0.70710678118654757,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.70710678118654757,\n                                0.70710678118654757,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.01657281518405971,\n                                 0.01657281518405971,\n                                 -0.12153397801643787,\n                                 -0.12153397801643787,\n                                 0.70710678118654757,\n                                 -0.70710678118654757,\n                                 0.12153397801643787,\n                                 0.12153397801643787,\n                                 -0.01657281518405971,\n                                 -0.01657281518405971\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"bior2.2\"){\n                double lp1_a[] = {0.0,\n                                -0.17677669529663689,\n                                0.35355339059327379,\n                                1.0606601717798214,\n                                0.35355339059327379,\n                                -0.17677669529663689\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.35355339059327379,\n                                -0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.35355339059327379,\n                                0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0,\n                                 0.17677669529663689,\n                                 0.35355339059327379,\n                                 -1.0606601717798214,\n                                 0.35355339059327379,\n                                 0.17677669529663689\n\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"bior2.4\"){\n                double lp1_a[] = {0.0,\n                                0.033145630368119419,\n                                -0.066291260736238838,\n                                -0.17677669529663689,\n                                0.4198446513295126,\n                                0.99436891104358249,\n                                0.4198446513295126,\n                                -0.17677669529663689,\n                                -0.066291260736238838,\n                                0.033145630368119419\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.35355339059327379,\n                                -0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.35355339059327379,\n                                0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0,\n                                 -0.033145630368119419,\n                                 -0.066291260736238838,\n                                 0.17677669529663689,\n                                 0.4198446513295126,\n                                 -0.99436891104358249,\n                                 0.4198446513295126,\n                                 0.17677669529663689,\n                                 -0.066291260736238838,\n                                 -0.033145630368119419\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"bior2.6\"){\n                double lp1_a[] = {0.0,\n                                -0.0069053396600248784,\n                                0.013810679320049757,\n                                0.046956309688169176,\n                                -0.10772329869638811,\n                                -0.16987135563661201,\n                                0.44746600996961211,\n                                0.96674755240348298,\n                                0.44746600996961211,\n                                -0.16987135563661201,\n                                -0.10772329869638811,\n                                0.046956309688169176,\n                                0.013810679320049757,\n                                -0.0069053396600248784\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.35355339059327379,\n                                -0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.35355339059327379,\n                                0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0,\n                                 0.0069053396600248784,\n                                 0.013810679320049757,\n                                 -0.046956309688169176,\n                                 -0.10772329869638811,\n                                 0.16987135563661201,\n                                 0.44746600996961211,\n                                 -0.96674755240348298,\n                                 0.44746600996961211,\n                                 0.16987135563661201,\n                                 -0.10772329869638811,\n                                 -0.046956309688169176,\n                                 0.013810679320049757,\n                                 0.0069053396600248784\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior2.8\"){\n                double lp1_a[] = {0.0,\n                                0.0015105430506304422,\n                                -0.0030210861012608843,\n                                -0.012947511862546647,\n                                0.028916109826354178,\n                                0.052998481890690945,\n                                -0.13491307360773608,\n                                -0.16382918343409025,\n                                0.46257144047591658,\n                                0.95164212189717856,\n                                0.46257144047591658,\n                                -0.16382918343409025,\n                                -0.13491307360773608,\n                                0.052998481890690945,\n                                0.028916109826354178,\n                                -0.012947511862546647,\n                                -0.0030210861012608843,\n                                0.0015105430506304422\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.35355339059327379,\n                                -0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.35355339059327379,\n                                0.70710678118654757,\n                                0.35355339059327379,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0,\n                                 -0.0015105430506304422,\n                                 -0.0030210861012608843,\n                                 0.012947511862546647,\n                                 0.028916109826354178,\n                                 -0.052998481890690945,\n                                 -0.13491307360773608,\n                                 0.16382918343409025,\n                                 0.46257144047591658,\n                                 -0.95164212189717856,\n                                 0.46257144047591658,\n                                 0.16382918343409025,\n                                 -0.13491307360773608,\n                                 -0.052998481890690945,\n                                 0.028916109826354178,\n                                 0.012947511862546647,\n                                 -0.0030210861012608843,\n                                 -0.0015105430506304422\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n\n    else if ( name == \"bior3.1\"){\n                double lp1_a[] = {-0.35355339059327379,\n                                1.0606601717798214,\n                                1.0606601717798214,\n                                -0.35355339059327379\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.17677669529663689,\n                                0.53033008588991071,\n                                -0.53033008588991071,\n                                0.17677669529663689\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.17677669529663689,\n                                0.53033008588991071,\n                                0.53033008588991071,\n                                0.17677669529663689\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.35355339059327379,\n                                 -1.0606601717798214,\n                                 1.0606601717798214,\n                                 0.35355339059327379\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior3.3\"){\n                double lp1_a[] = {0.066291260736238838,\n                                -0.19887378220871652,\n                                -0.15467960838455727,\n                                0.99436891104358249,\n                                0.99436891104358249,\n                                -0.15467960838455727,\n                                -0.19887378220871652,\n                                0.066291260736238838\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                -0.17677669529663689,\n                                0.53033008588991071,\n                                -0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.17677669529663689,\n                                0.53033008588991071,\n                                0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.066291260736238838,\n                                 0.19887378220871652,\n                                 -0.15467960838455727,\n                                 -0.99436891104358249,\n                                 0.99436891104358249,\n                                 0.15467960838455727,\n                                 -0.19887378220871652,\n                                 -0.066291260736238838\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior3.5\"){\n                double lp1_a[] = {-0.013810679320049757,\n                                0.041432037960149271,\n                                0.052480581416189075,\n                                -0.26792717880896527,\n                                -0.071815532464258744,\n                                0.96674755240348298,\n                                0.96674755240348298,\n                                -0.071815532464258744,\n                                -0.26792717880896527,\n                                0.052480581416189075,\n                                0.041432037960149271,\n                                -0.013810679320049757\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                -0.17677669529663689,\n                                0.53033008588991071,\n                                -0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.17677669529663689,\n                                0.53033008588991071,\n                                0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.013810679320049757,\n                                 -0.041432037960149271,\n                                 0.052480581416189075,\n                                 0.26792717880896527,\n                                 -0.071815532464258744,\n                                 -0.96674755240348298,\n                                 0.96674755240348298,\n                                 0.071815532464258744,\n                                 -0.26792717880896527,\n                                 -0.052480581416189075,\n                                 0.041432037960149271,\n                                 0.013810679320049757\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n\n    else if ( name == \"bior3.7\"){\n                double lp1_a[] = {0.0030210861012608843,\n                                -0.0090632583037826529,\n                                -0.016831765421310641,\n                                0.074663985074019001,\n                                0.031332978707362888,\n                                -0.301159125922835,\n                                -0.026499240945345472,\n                                0.95164212189717856,\n                                0.95164212189717856,\n                                -0.026499240945345472,\n                                -0.301159125922835,\n                                0.031332978707362888,\n                                0.074663985074019001,\n                                -0.016831765421310641,\n                                -0.0090632583037826529,\n                                0.0030210861012608843\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                -0.17677669529663689,\n                                0.53033008588991071,\n                                -0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.17677669529663689,\n                                0.53033008588991071,\n                                0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0030210861012608843,\n                                 0.0090632583037826529,\n                                 -0.016831765421310641,\n                                 -0.074663985074019001,\n                                 0.031332978707362888,\n                                 0.301159125922835,\n                                 -0.026499240945345472,\n                                 -0.95164212189717856,\n                                 0.95164212189717856,\n                                 0.026499240945345472,\n                                 -0.301159125922835,\n                                 -0.031332978707362888,\n                                 0.074663985074019001,\n                                 0.016831765421310641,\n                                 -0.0090632583037826529,\n                                 -0.0030210861012608843\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior3.9\"){\n                double lp1_a[] = {-0.00067974437278369901,\n                                0.0020392331183510968,\n                                0.0050603192196119811,\n                                -0.020618912641105536,\n                                -0.014112787930175846,\n                                0.09913478249423216,\n                                0.012300136269419315,\n                                -0.32019196836077857,\n                                0.0020500227115698858,\n                                0.94212570067820678,\n                                0.94212570067820678,\n                                0.0020500227115698858,\n                                -0.32019196836077857,\n                                0.012300136269419315,\n                                0.09913478249423216,\n                                -0.014112787930175846,\n                                -0.020618912641105536,\n                                0.0050603192196119811,\n                                0.0020392331183510968,\n                                -0.00067974437278369901\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                -0.17677669529663689,\n                                0.53033008588991071,\n                                -0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.17677669529663689,\n                                0.53033008588991071,\n                                0.53033008588991071,\n                                0.17677669529663689,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.00067974437278369901,\n                                 -0.0020392331183510968,\n                                 0.0050603192196119811,\n                                 0.020618912641105536,\n                                 -0.014112787930175846,\n                                 -0.09913478249423216,\n                                 0.012300136269419315,\n                                 0.32019196836077857,\n                                 0.0020500227115698858,\n                                 -0.94212570067820678,\n                                 0.94212570067820678,\n                                 -0.0020500227115698858,\n                                 -0.32019196836077857,\n                                 -0.012300136269419315,\n                                 0.09913478249423216,\n                                 0.014112787930175846,\n                                 -0.020618912641105536,\n                                 -0.0050603192196119811,\n                                 0.0020392331183510968,\n                                 0.00067974437278369901\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior4.4\"){\n                double lp1_a[] = {0.0,\n                                0.03782845550726404,\n                                -0.023849465019556843,\n                                -0.11062440441843718,\n                                0.37740285561283066,\n                                0.85269867900889385,\n                                0.37740285561283066,\n                                -0.11062440441843718,\n                                -0.023849465019556843,\n                                0.03782845550726404\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                -0.064538882628697058,\n                                0.040689417609164058,\n                                0.41809227322161724,\n                                -0.7884856164055829,\n                                0.41809227322161724,\n                                0.040689417609164058,\n                                -0.064538882628697058,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                -0.064538882628697058,\n                                -0.040689417609164058,\n                                0.41809227322161724,\n                                0.7884856164055829,\n                                0.41809227322161724,\n                                -0.040689417609164058,\n                                -0.064538882628697058,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0,\n                                 -0.03782845550726404,\n                                 -0.023849465019556843,\n                                 0.11062440441843718,\n                                 0.37740285561283066,\n                                 -0.85269867900889385,\n                                 0.37740285561283066,\n                                 0.11062440441843718,\n                                 -0.023849465019556843,\n                                 -0.03782845550726404\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior5.5\"){\n                double lp1_a[] = {0.0,\n                                0.0,\n                                0.03968708834740544,\n                                0.0079481086372403219,\n                                -0.054463788468236907,\n                                0.34560528195603346,\n                                0.73666018142821055,\n                                0.34560528195603346,\n                                -0.054463788468236907,\n                                0.0079481086372403219,\n                                0.03968708834740544,\n                                0.0\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.013456709459118716,\n                                -0.0026949668801115071,\n                                0.13670658466432914,\n                                -0.093504697400938863,\n                                -0.47680326579848425,\n                                0.89950610974864842,\n                                -0.47680326579848425,\n                                -0.093504697400938863,\n                                0.13670658466432914,\n                                -0.0026949668801115071,\n                                -0.013456709459118716,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.013456709459118716,\n                                -0.0026949668801115071,\n                                -0.13670658466432914,\n                                -0.093504697400938863,\n                                0.47680326579848425,\n                                0.89950610974864842,\n                                0.47680326579848425,\n                                -0.093504697400938863,\n                                -0.13670658466432914,\n                                -0.0026949668801115071,\n                                0.013456709459118716,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0,\n                                 0.0,\n                                 0.03968708834740544,\n                                 -0.0079481086372403219,\n                                 -0.054463788468236907,\n                                 -0.34560528195603346,\n                                 0.73666018142821055,\n                                 -0.34560528195603346,\n                                 -0.054463788468236907,\n                                 -0.0079481086372403219,\n                                 0.03968708834740544,\n                                 0.0\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"bior6.8\"){\n                double lp1_a[] = {0.0,\n                                0.0019088317364812906,\n                                -0.0019142861290887667,\n                                -0.016990639867602342,\n                                0.01193456527972926,\n                                0.04973290349094079,\n                                -0.077263173167204144,\n                                -0.09405920349573646,\n                                0.42079628460982682,\n                                0.82592299745840225,\n                                0.42079628460982682,\n                                -0.09405920349573646,\n                                -0.077263173167204144,\n                                0.04973290349094079,\n                                0.01193456527972926,\n                                -0.016990639867602342,\n                                -0.0019142861290887667,\n                                0.0019088317364812906\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.014426282505624435,\n                                -0.014467504896790148,\n                                -0.078722001062628819,\n                                0.040367979030339923,\n                                0.41784910915027457,\n                                -0.75890772945365415,\n                                0.41784910915027457,\n                                0.040367979030339923,\n                                -0.078722001062628819,\n                                -0.014467504896790148,\n                                0.014426282505624435,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0,\n                                0.0,\n                                0.0,\n                                0.014426282505624435,\n                                0.014467504896790148,\n                                -0.078722001062628819,\n                                -0.040367979030339923,\n                                0.41784910915027457,\n                                0.75890772945365415,\n                                0.41784910915027457,\n                                -0.040367979030339923,\n                                -0.078722001062628819,\n                                0.014467504896790148,\n                                0.014426282505624435,\n                                0.0,\n                                0.0,\n                                0.0,\n                                0.0\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0,\n                                 -0.0019088317364812906,\n                                 -0.0019142861290887667,\n                                 0.016990639867602342,\n                                 0.01193456527972926,\n                                 -0.04973290349094079,\n                                 -0.077263173167204144,\n                                 0.09405920349573646,\n                                 0.42079628460982682,\n                                 -0.82592299745840225,\n                                 0.42079628460982682,\n                                 0.09405920349573646,\n                                 -0.077263173167204144,\n                                 -0.04973290349094079,\n                                 0.01193456527972926,\n                                 0.016990639867602342,\n                                 -0.0019142861290887667,\n                                 -0.0019088317364812906\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n\n    else if ( name == \"coif1\"){\n                double lp1_a[] = {-0.01565572813546454,\n                                -0.072732619512853897,\n                                0.38486484686420286,\n                                0.85257202021225542,\n                                0.33789766245780922,\n                                -0.072732619512853897\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.072732619512853897,\n                                0.33789766245780922,\n                                -0.85257202021225542,\n                                0.38486484686420286,\n                                0.072732619512853897,\n                                -0.01565572813546454\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {-0.072732619512853897,\n                                0.33789766245780922,\n                                0.85257202021225542,\n                                0.38486484686420286,\n                                -0.072732619512853897,\n                                -0.01565572813546454\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.01565572813546454,\n                                 0.072732619512853897,\n                                 0.38486484686420286,\n                                 -0.85257202021225542,\n                                 0.33789766245780922,\n                                 0.072732619512853897\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"coif2\"){\n                double lp1_a[] = {-0.00072054944536451221,\n                                -0.0018232088707029932,\n                                0.0056114348193944995,\n                                0.023680171946334084,\n                                -0.059434418646456898,\n                                -0.076488599078306393,\n                                0.41700518442169254,\n                                0.81272363544554227,\n                                0.38611006682116222,\n                                -0.067372554721963018,\n                                -0.041464936781759151,\n                                0.016387336463522112\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.016387336463522112,\n                                -0.041464936781759151,\n                                0.067372554721963018,\n                                0.38611006682116222,\n                                -0.81272363544554227,\n                                0.41700518442169254,\n                                0.076488599078306393,\n                                -0.059434418646456898,\n                                -0.023680171946334084,\n                                0.0056114348193944995,\n                                0.0018232088707029932,\n                                -0.00072054944536451221\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.016387336463522112,\n                                -0.041464936781759151,\n                                -0.067372554721963018,\n                                0.38611006682116222,\n                                0.81272363544554227,\n                                0.41700518442169254,\n                                -0.076488599078306393,\n                                -0.059434418646456898,\n                                0.023680171946334084,\n                                0.0056114348193944995,\n                                -0.0018232088707029932,\n                                -0.00072054944536451221\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.00072054944536451221,\n                                 0.0018232088707029932,\n                                 0.0056114348193944995,\n                                 -0.023680171946334084,\n                                 -0.059434418646456898,\n                                 0.076488599078306393,\n                                 0.41700518442169254,\n                                 -0.81272363544554227,\n                                 0.38611006682116222,\n                                 0.067372554721963018,\n                                 -0.041464936781759151,\n                                 -0.016387336463522112\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"coif3\"){\n                double lp1_a[] = {-3.4599772836212559e-05,\n                                -7.0983303138141252e-05,\n                                0.00046621696011288631,\n                                0.0011175187708906016,\n                                -0.0025745176887502236,\n                                -0.0090079761366615805,\n                                0.015880544863615904,\n                                0.034555027573061628,\n                                -0.082301927106885983,\n                                -0.071799821619312018,\n                                0.42848347637761874,\n                                0.79377722262562056,\n                                0.4051769024096169,\n                                -0.061123390002672869,\n                                -0.0657719112818555,\n                                0.023452696141836267,\n                                0.0077825964273254182,\n                                -0.0037935128644910141\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.0037935128644910141,\n                                0.0077825964273254182,\n                                -0.023452696141836267,\n                                -0.0657719112818555,\n                                0.061123390002672869,\n                                0.4051769024096169,\n                                -0.79377722262562056,\n                                0.42848347637761874,\n                                0.071799821619312018,\n                                -0.082301927106885983,\n                                -0.034555027573061628,\n                                0.015880544863615904,\n                                0.0090079761366615805,\n                                -0.0025745176887502236,\n                                -0.0011175187708906016,\n                                0.00046621696011288631,\n                                7.0983303138141252e-05,\n                                -3.4599772836212559e-05\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {-0.0037935128644910141,\n                                0.0077825964273254182,\n                                0.023452696141836267,\n                                -0.0657719112818555,\n                                -0.061123390002672869,\n                                0.4051769024096169,\n                                0.79377722262562056,\n                                0.42848347637761874,\n                                -0.071799821619312018,\n                                -0.082301927106885983,\n                                0.034555027573061628,\n                                0.015880544863615904,\n                                -0.0090079761366615805,\n                                -0.0025745176887502236,\n                                0.0011175187708906016,\n                                0.00046621696011288631,\n                                -7.0983303138141252e-05,\n                                -3.4599772836212559e-05\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-3.4599772836212559e-05,\n                                 7.0983303138141252e-05,\n                                 0.00046621696011288631,\n                                 -0.0011175187708906016,\n                                 -0.0025745176887502236,\n                                 0.0090079761366615805,\n                                 0.015880544863615904,\n                                 -0.034555027573061628,\n                                 -0.082301927106885983,\n                                 0.071799821619312018,\n                                 0.42848347637761874,\n                                 -0.79377722262562056,\n                                 0.4051769024096169,\n                                 0.061123390002672869,\n                                 -0.0657719112818555,\n                                 -0.023452696141836267,\n                                 0.0077825964273254182,\n                                 0.0037935128644910141\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"coif4\"){\n                double lp1_a[] = {-1.7849850030882614e-06,\n                                -3.2596802368833675e-06,\n                                3.1229875865345646e-05,\n                                6.2339034461007128e-05,\n                                -0.00025997455248771324,\n                                -0.00058902075624433831,\n                                0.0012665619292989445,\n                                0.0037514361572784571,\n                                -0.0056582866866107199,\n                                -0.015211731527946259,\n                                0.025082261844864097,\n                                0.039334427123337491,\n                                -0.096220442033987982,\n                                -0.066627474263425038,\n                                0.4343860564914685,\n                                0.78223893092049901,\n                                0.41530840703043026,\n                                -0.056077313316754807,\n                                -0.081266699680878754,\n                                0.026682300156053072,\n                                0.016068943964776348,\n                                -0.0073461663276420935,\n                                -0.0016294920126017326,\n                                0.00089231366858231456\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.00089231366858231456,\n                                -0.0016294920126017326,\n                                0.0073461663276420935,\n                                0.016068943964776348,\n                                -0.026682300156053072,\n                                -0.081266699680878754,\n                                0.056077313316754807,\n                                0.41530840703043026,\n                                -0.78223893092049901,\n                                0.4343860564914685,\n                                0.066627474263425038,\n                                -0.096220442033987982,\n                                -0.039334427123337491,\n                                0.025082261844864097,\n                                0.015211731527946259,\n                                -0.0056582866866107199,\n                                -0.0037514361572784571,\n                                0.0012665619292989445,\n                                0.00058902075624433831,\n                                -0.00025997455248771324,\n                                -6.2339034461007128e-05,\n                                3.1229875865345646e-05,\n                                3.2596802368833675e-06,\n                                -1.7849850030882614e-06\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.00089231366858231456,\n                                -0.0016294920126017326,\n                                -0.0073461663276420935,\n                                0.016068943964776348,\n                                0.026682300156053072,\n                                -0.081266699680878754,\n                                -0.056077313316754807,\n                                0.41530840703043026,\n                                0.78223893092049901,\n                                0.4343860564914685,\n                                -0.066627474263425038,\n                                -0.096220442033987982,\n                                0.039334427123337491,\n                                0.025082261844864097,\n                                -0.015211731527946259,\n                                -0.0056582866866107199,\n                                0.0037514361572784571,\n                                0.0012665619292989445,\n                                -0.00058902075624433831,\n                                -0.00025997455248771324,\n                                6.2339034461007128e-05,\n                                3.1229875865345646e-05,\n                                -3.2596802368833675e-06,\n                                -1.7849850030882614e-06\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-1.7849850030882614e-06,\n                                 3.2596802368833675e-06,\n                                 3.1229875865345646e-05,\n                                 -6.2339034461007128e-05,\n                                 -0.00025997455248771324,\n                                 0.00058902075624433831,\n                                 0.0012665619292989445,\n\n                                 -0.0037514361572784571,\n                                 -0.0056582866866107199,\n                                 0.015211731527946259,\n                                 0.025082261844864097,\n                                 -0.039334427123337491,\n                                 -0.096220442033987982,\n                                 0.066627474263425038,\n                                 0.4343860564914685,\n                                 -0.78223893092049901,\n                                 0.41530840703043026,\n                                 0.056077313316754807,\n                                 -0.081266699680878754,\n                                 -0.026682300156053072,\n                                 0.016068943964776348,\n                                 0.0073461663276420935,\n                                 -0.0016294920126017326,\n                                 -0.00089231366858231456\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n    else if ( name == \"coif5\"){\n                double lp1_a[] = {-9.517657273819165e-08,\n                                -1.6744288576823017e-07,\n                                2.0637618513646814e-06,\n                                3.7346551751414047e-06,\n                                -2.1315026809955787e-05,\n                                -4.1340432272512511e-05,\n                                0.00014054114970203437,\n                                0.00030225958181306315,\n                                -0.00063813134304511142,\n                                -0.0016628637020130838,\n                                0.0024333732126576722,\n                                0.0067641854480530832,\n                                -0.0091642311624818458,\n                                -0.019761778942572639,\n                                0.032683574267111833,\n                                0.041289208750181702,\n                                -0.10557420870333893,\n                                -0.062035963962903569,\n                                0.43799162617183712,\n                                0.77428960365295618,\n                                0.42156620669085149,\n                                -0.052043163176243773,\n                                -0.091920010559696244,\n                                0.02816802897093635,\n                                0.023408156785839195,\n                                -0.010131117519849788,\n                                -0.004159358781386048,\n                                0.0021782363581090178,\n                                0.00035858968789573785,\n                                -0.00021208083980379827\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.00021208083980379827,\n                                0.00035858968789573785,\n                                -0.0021782363581090178,\n                                -0.004159358781386048,\n                                0.010131117519849788,\n                                0.023408156785839195,\n                                -0.02816802897093635,\n                                -0.091920010559696244,\n                                0.052043163176243773,\n                                0.42156620669085149,\n                                -0.77428960365295618,\n                                0.43799162617183712,\n                                0.062035963962903569,\n                                -0.10557420870333893,\n                                -0.041289208750181702,\n                                0.032683574267111833,\n                                0.019761778942572639,\n                                -0.0091642311624818458,\n                                -0.0067641854480530832,\n                                0.0024333732126576722,\n                                0.0016628637020130838,\n                                -0.00063813134304511142,\n                                -0.00030225958181306315,\n                                0.00014054114970203437,\n                                4.1340432272512511e-05,\n                                -2.1315026809955787e-05,\n                                -3.7346551751414047e-06,\n                                2.0637618513646814e-06,\n                                1.6744288576823017e-07,\n                                -9.517657273819165e-08\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {-0.00021208083980379827,\n                                0.00035858968789573785,\n                                0.0021782363581090178,\n                                -0.004159358781386048,\n                                -0.010131117519849788,\n                                0.023408156785839195,\n                                0.02816802897093635,\n                                -0.091920010559696244,\n                                -0.052043163176243773,\n                                0.42156620669085149,\n                                0.77428960365295618,\n                                0.43799162617183712,\n                                -0.062035963962903569,\n                                -0.10557420870333893,\n                                0.041289208750181702,\n                                0.032683574267111833,\n                                -0.019761778942572639,\n                                -0.0091642311624818458,\n                                0.0067641854480530832,\n                                0.0024333732126576722,\n                                -0.0016628637020130838,\n                                -0.00063813134304511142,\n                                0.00030225958181306315,\n                                0.00014054114970203437,\n                                -4.1340432272512511e-05,\n                                -2.1315026809955787e-05,\n                                3.7346551751414047e-06,\n                                2.0637618513646814e-06,\n                                -1.6744288576823017e-07,\n                                -9.517657273819165e-08\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-9.517657273819165e-08,\n                                 1.6744288576823017e-07,\n                                 2.0637618513646814e-06,\n                                 -3.7346551751414047e-06,\n                                 -2.1315026809955787e-05,\n                                 4.1340432272512511e-05,\n                                 0.00014054114970203437,\n                                 -0.00030225958181306315,\n                                 -0.00063813134304511142,\n                                 0.0016628637020130838,\n                                 0.0024333732126576722,\n                                 -0.0067641854480530832,\n                                 -0.0091642311624818458,\n                                 0.019761778942572639,\n                                 0.032683574267111833,\n                                 -0.041289208750181702,\n                                 -0.10557420870333893,\n                                 0.062035963962903569,\n                                 0.43799162617183712,\n                                 -0.77428960365295618,\n                                 0.42156620669085149,\n                                 0.052043163176243773,\n                                 -0.091920010559696244,\n                                 -0.02816802897093635,\n                                 0.023408156785839195,\n                                 0.010131117519849788,\n                                 -0.004159358781386048,\n                                 -0.0021782363581090178,\n                                 0.00035858968789573785,\n                                 0.00021208083980379827\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n            }\n\n    else if ( name == \"sym2\"){\n                double lp1_a[] = {-0.12940952255092145,\n                                  0.22414386804185735,\n                                  0.83651630373746899,\n                                  0.48296291314469025\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.48296291314469025,\n                                  0.83651630373746899,\n                                  -0.22414386804185735,\n                                  -0.12940952255092145\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.48296291314469025,\n                                  0.83651630373746899,\n                                  0.22414386804185735,\n                                  -0.12940952255092145\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.12940952255092145,\n                                   -0.22414386804185735,\n                                   0.83651630373746899,\n                                   -0.48296291314469025\n\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym3\"){\n                double lp1_a[] = {0.035226291882100656,\n                                  -0.085441273882241486,\n                                  -0.13501102001039084,\n                                  0.45987750211933132,\n                                  0.80689150931333875,\n                                  0.33267055295095688\n\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.33267055295095688,\n                                  0.80689150931333875,\n                                  -0.45987750211933132,\n                                  -0.13501102001039084,\n                                  0.085441273882241486,\n                                  0.035226291882100656\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.33267055295095688,\n                                  0.80689150931333875,\n                                  0.45987750211933132,\n                                  -0.13501102001039084,\n                                  -0.085441273882241486,\n                                  0.035226291882100656\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.035226291882100656,\n                                   0.085441273882241486,\n                                   -0.13501102001039084,\n                                   -0.45987750211933132,\n                                   0.80689150931333875,\n                                   -0.33267055295095688\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym4\"){\n                double lp1_a[] = {-0.075765714789273325,\n                                  -0.02963552764599851,\n                                  0.49761866763201545,\n                                  0.80373875180591614,\n                                  0.29785779560527736,\n                                  -0.099219543576847216,\n                                  -0.012603967262037833,\n                                  0.032223100604042702\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.032223100604042702,\n                                  -0.012603967262037833,\n                                  0.099219543576847216,\n                                  0.29785779560527736,\n                                  -0.80373875180591614,\n                                  0.49761866763201545,\n                                  0.02963552764599851,\n                                  -0.075765714789273325\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.032223100604042702,\n                                  -0.012603967262037833,\n                                  -0.099219543576847216,\n                                  0.29785779560527736,\n                                  0.80373875180591614,\n                                  0.49761866763201545,\n                                  -0.02963552764599851,\n                                  -0.075765714789273325\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.075765714789273325,\n                                   0.02963552764599851,\n                                   0.49761866763201545,\n                                   -0.80373875180591614,\n                                   0.29785779560527736,\n                                   0.099219543576847216,\n                                   -0.012603967262037833,\n                                   -0.032223100604042702\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym5\"){\n                double lp1_a[] = {0.027333068345077982,\n                                  0.029519490925774643,\n                                  -0.039134249302383094,\n                                  0.1993975339773936,\n                                  0.72340769040242059,\n                                  0.63397896345821192,\n                                  0.016602105764522319,\n                                  -0.17532808990845047,\n                                  -0.021101834024758855,\n                                  0.019538882735286728\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.019538882735286728,\n                                  -0.021101834024758855,\n                                  0.17532808990845047,\n                                  0.016602105764522319,\n                                  -0.63397896345821192,\n                                  0.72340769040242059,\n                                  -0.1993975339773936,\n                                  -0.039134249302383094,\n                                  -0.029519490925774643,\n                                  0.027333068345077982\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.019538882735286728,\n                                  -0.021101834024758855,\n                                  -0.17532808990845047,\n                                  0.016602105764522319,\n                                  0.63397896345821192,\n                                  0.72340769040242059,\n                                  0.1993975339773936,\n                                  -0.039134249302383094,\n                                  0.029519490925774643,\n                                  0.027333068345077982\n\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.027333068345077982,\n                                   -0.029519490925774643,\n                                   -0.039134249302383094,\n                                   -0.1993975339773936,\n                                   0.72340769040242059,\n                                   -0.63397896345821192,\n                                   0.016602105764522319,\n                                   0.17532808990845047,\n                                   -0.021101834024758855,\n                                   -0.019538882735286728\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym6\"){\n                double lp1_a[] = {0.015404109327027373,\n                                  0.0034907120842174702,\n                                  -0.11799011114819057,\n                                  -0.048311742585632998,\n                                  0.49105594192674662,\n                                  0.787641141030194,\n                                  0.3379294217276218,\n                                  -0.072637522786462516,\n                                  -0.021060292512300564,\n                                  0.044724901770665779,\n                                  0.0017677118642428036,\n                                  -0.007800708325034148\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.007800708325034148,\n                                  0.0017677118642428036,\n                                  -0.044724901770665779,\n                                  -0.021060292512300564,\n                                  0.072637522786462516,\n                                  0.3379294217276218,\n                                  -0.787641141030194,\n                                  0.49105594192674662,\n                                  0.048311742585632998,\n                                  -0.11799011114819057,\n                                  -0.0034907120842174702,\n                                  0.015404109327027373\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {-0.007800708325034148,\n                                  0.0017677118642428036,\n                                  0.044724901770665779,\n                                  -0.021060292512300564,\n                                  -0.072637522786462516,\n                                  0.3379294217276218,\n                                  0.787641141030194,\n                                  0.49105594192674662,\n                                  -0.048311742585632998,\n                                  -0.11799011114819057,\n                                  0.0034907120842174702,\n                                  0.015404109327027373\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.015404109327027373,\n                                   -0.0034907120842174702,\n                                   -0.11799011114819057,\n                                   0.048311742585632998,\n                                   0.49105594192674662,\n                                   -0.787641141030194,\n                                   0.3379294217276218,\n                                   0.072637522786462516,\n                                   -0.021060292512300564,\n                                   -0.044724901770665779,\n                                   0.0017677118642428036,\n                                   0.007800708325034148\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym7\"){\n                double lp1_a[] = {0.0026818145682578781,\n                                  -0.0010473848886829163,\n                                  -0.01263630340325193,\n                                  0.03051551316596357,\n                                  0.067892693501372697,\n                                  -0.049552834937127255,\n                                  0.017441255086855827,\n                                  0.5361019170917628,\n                                  0.76776431700316405,\n                                  0.28862963175151463,\n                                  -0.14004724044296152,\n                                  -0.10780823770381774,\n                                  0.0040102448715336634,\n                                  0.010268176708511255\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.010268176708511255,\n                                  0.0040102448715336634,\n                                  0.10780823770381774,\n                                  -0.14004724044296152,\n                                  -0.28862963175151463,\n                                  0.76776431700316405,\n                                  -0.5361019170917628,\n                                  0.017441255086855827,\n                                  0.049552834937127255,\n                                  0.067892693501372697,\n                                  -0.03051551316596357,\n                                  -0.01263630340325193,\n                                  0.0010473848886829163,\n                                  0.0026818145682578781\n\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.010268176708511255,\n                                  0.0040102448715336634,\n                                  -0.10780823770381774,\n                                  -0.14004724044296152,\n                                  0.28862963175151463,\n                                  0.76776431700316405,\n                                  0.5361019170917628,\n                                  0.017441255086855827,\n                                  -0.049552834937127255,\n                                  0.067892693501372697,\n                                  0.03051551316596357,\n                                  -0.01263630340325193,\n                                  -0.0010473848886829163,\n                                  0.0026818145682578781\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0026818145682578781,\n                                   0.0010473848886829163,\n                                   -0.01263630340325193,\n                                   -0.03051551316596357,\n                                   0.067892693501372697,\n                                   0.049552834937127255,\n                                   0.017441255086855827,\n                                   -0.5361019170917628,\n                                   0.76776431700316405,\n                                   -0.28862963175151463,\n                                   -0.14004724044296152,\n                                   0.10780823770381774,\n                                   0.0040102448715336634,\n                                   -0.010268176708511255\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym8\"){\n                double lp1_a[] = {-0.0033824159510061256,\n                                  -0.00054213233179114812,\n                                  0.031695087811492981,\n                                  0.0076074873249176054,\n                                  -0.14329423835080971,\n                                  -0.061273359067658524,\n                                  0.48135965125837221,\n                                  0.77718575170052351,\n                                  0.3644418948353314,\n                                  -0.051945838107709037,\n                                  -0.027219029917056003,\n                                  0.049137179673607506,\n                                  0.0038087520138906151,\n                                  -0.014952258337048231,\n                                  -0.0003029205147213668,\n                                  0.0018899503327594609\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.0018899503327594609,\n                                  -0.0003029205147213668,\n                                  0.014952258337048231,\n                                  0.0038087520138906151,\n                                  -0.049137179673607506,\n                                  -0.027219029917056003,\n                                  0.051945838107709037,\n                                  0.3644418948353314,\n                                  -0.77718575170052351,\n                                  0.48135965125837221,\n                                  0.061273359067658524,\n                                  -0.14329423835080971,\n                                  -0.0076074873249176054,\n                                  0.031695087811492981,\n                                  0.00054213233179114812,\n                                  -0.0033824159510061256\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0018899503327594609,\n                                  -0.0003029205147213668,\n                                  -0.014952258337048231,\n                                  0.0038087520138906151,\n                                  0.049137179673607506,\n                                  -0.027219029917056003,\n                                  -0.051945838107709037,\n                                  0.3644418948353314,\n                                  0.77718575170052351,\n                                  0.48135965125837221,\n                                  -0.061273359067658524,\n                                  -0.14329423835080971,\n                                  0.0076074873249176054,\n                                  0.031695087811492981,\n                                  -0.00054213233179114812,\n                                  -0.0033824159510061256\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {-0.0033824159510061256,\n                                   0.00054213233179114812,\n                                   0.031695087811492981,\n                                   -0.0076074873249176054,\n                                   -0.14329423835080971,\n                                   0.061273359067658524,\n                                   0.48135965125837221,\n                                   -0.77718575170052351,\n                                   0.3644418948353314,\n                                   0.051945838107709037,\n                                   -0.027219029917056003,\n                                   -0.049137179673607506,\n                                   0.0038087520138906151,\n                                   0.014952258337048231,\n                                   -0.0003029205147213668,\n                                   -0.0018899503327594609\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym9\"){\n                double lp1_a[] = {0.0014009155259146807,\n                                  0.00061978088898558676,\n                                  -0.013271967781817119,\n                                  -0.01152821020767923,\n                                  0.03022487885827568,\n                                  0.00058346274612580684,\n                                  -0.054568958430834071,\n                                  0.238760914607303,\n                                  0.717897082764412,\n                                  0.61733844914093583,\n                                  0.035272488035271894,\n                                  -0.19155083129728512,\n                                  -0.018233770779395985,\n                                  0.06207778930288603,\n                                  0.0088592674934004842,\n                                  -0.010264064027633142,\n                                  -0.00047315449868008311,\n                                  0.0010694900329086053\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {-0.0010694900329086053,\n                                  -0.00047315449868008311,\n                                  0.010264064027633142,\n                                  0.0088592674934004842,\n                                  -0.06207778930288603,\n                                  -0.018233770779395985,\n                                  0.19155083129728512,\n                                  0.035272488035271894,\n                                  -0.61733844914093583,\n                                  0.717897082764412,\n                                  -0.238760914607303,\n                                  -0.054568958430834071,\n                                  -0.00058346274612580684,\n                                  0.03022487885827568,\n                                  0.01152821020767923,\n                                  -0.013271967781817119,\n                                  -0.00061978088898558676,\n                                  0.0014009155259146807\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {0.0010694900329086053,\n                                  -0.00047315449868008311,\n                                  -0.010264064027633142,\n                                  0.0088592674934004842,\n                                  0.06207778930288603,\n                                  -0.018233770779395985,\n                                  -0.19155083129728512,\n                                  0.035272488035271894,\n                                  0.61733844914093583,\n                                  0.717897082764412,\n                                  0.238760914607303,\n                                  -0.054568958430834071,\n                                  0.00058346274612580684,\n                                  0.03022487885827568,\n                                  -0.01152821020767923,\n                                  -0.013271967781817119,\n                                  0.00061978088898558676,\n                                  0.0014009155259146807\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.0014009155259146807,\n                                   -0.00061978088898558676,\n                                   -0.013271967781817119,\n                                   0.01152821020767923,\n                                   0.03022487885827568,\n                                   -0.00058346274612580684,\n                                   -0.054568958430834071,\n                                   -0.238760914607303,\n                                   0.717897082764412,\n                                   -0.61733844914093583,\n                                   0.035272488035271894,\n                                   0.19155083129728512,\n                                   -0.018233770779395985,\n                                   -0.06207778930288603,\n                                   0.0088592674934004842,\n                                   0.010264064027633142,\n                                   -0.00047315449868008311,\n                                   -0.0010694900329086053\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n    else if ( name == \"sym10\"){\n                double lp1_a[] = {0.00077015980911449011,\n                                  9.5632670722894754e-05,\n                                  -0.0086412992770224222,\n                                  -0.0014653825813050513,\n                                  0.045927239231092203,\n                                  0.011609893903711381,\n                                  -0.15949427888491757,\n                                  -0.070880535783243853,\n                                  0.47169066693843925,\n                                  0.7695100370211071,\n                                  0.38382676106708546,\n                                  -0.035536740473817552,\n                                  -0.0319900568824278,\n                                  0.049994972077376687,\n                                  0.0057649120335819086,\n                                  -0.02035493981231129,\n                                  -0.00080435893201654491,\n                                  0.0045931735853118284,\n                                  5.7036083618494284e-05,\n                                  -0.00045932942100465878\n};\n                lp1.assign (lp1_a,lp1_a + sizeof(lp1_a)/sizeof(double));\n\n                double hp1_a[] = {0.00045932942100465878,\n                                  5.7036083618494284e-05,\n                                  -0.0045931735853118284,\n                                  -0.00080435893201654491,\n                                  0.02035493981231129,\n                                  0.0057649120335819086,\n                                  -0.049994972077376687,\n                                  -0.0319900568824278,\n                                  0.035536740473817552,\n                                  0.38382676106708546,\n                                  -0.7695100370211071,\n                                  0.47169066693843925,\n                                  0.070880535783243853,\n                                  -0.15949427888491757,\n                                  -0.011609893903711381,\n                                  0.045927239231092203,\n                                  0.0014653825813050513,\n                                  -0.0086412992770224222,\n                                  -9.5632670722894754e-05,\n                                  0.00077015980911449011\n};\n                 hp1.assign (hp1_a,hp1_a + sizeof(hp1_a)/sizeof(double));\n\n                double lp2_a[] = {-0.00045932942100465878,\n                                  5.7036083618494284e-05,\n                                  0.0045931735853118284,\n                                  -0.00080435893201654491,\n                                  -0.02035493981231129,\n                                  0.0057649120335819086,\n                                  0.049994972077376687,\n                                  -0.0319900568824278,\n                                  -0.035536740473817552,\n                                  0.38382676106708546,\n                                  0.7695100370211071,\n                                  0.47169066693843925,\n                                  -0.070880535783243853,\n                                  -0.15949427888491757,\n                                  0.011609893903711381,\n                                  0.045927239231092203,\n                                  -0.0014653825813050513,\n                                  -0.0086412992770224222,\n                                  9.5632670722894754e-05,\n                                  0.00077015980911449011\n};\n                 lp2.assign (lp2_a,lp2_a + sizeof(lp2_a)/sizeof(double));\n\n                 double hp2_a[] = {0.00077015980911449011,\n                                   -9.5632670722894754e-05,\n                                   -0.0086412992770224222,\n                                   0.0014653825813050513,\n                                   0.045927239231092203,\n                                   -0.011609893903711381,\n                                   -0.15949427888491757,\n                                   0.070880535783243853,\n                                   0.47169066693843925,\n                                   -0.7695100370211071,\n                                   0.38382676106708546,\n                                   0.035536740473817552,\n                                   -0.0319900568824278,\n                                   -0.049994972077376687,\n                                   0.0057649120335819086,\n                                   0.02035493981231129,\n                                   -0.00080435893201654491,\n                                   -0.0045931735853118284,\n                                   5.7036083618494284e-05,\n                                   0.00045932942100465878\n};\n                 hp2.assign (hp2_a,hp2_a + sizeof(hp2_a)/sizeof(double));\n                 return 0;\n        }\n\n\n    else {\n        cout << \"Filter Not in Database\" << endl;\n        return -1;\n    }\n\n}\n\n\n\n\n",
    "created" : 1476130091067.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "64622740",
    "id" : "BD901988",
    "lastKnownWriteTime" : 1436146423,
    "last_content_update" : 1436146423,
    "path" : "~/GitHub/fisseq/src/wavelet2d.cpp",
    "project_path" : "src/wavelet2d.cpp",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}