{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n// OpenCV\n#include \"opencv2/opencv.hpp\"\n#include \"opencv2/opencv_modules.hpp\"\n#include \"opencv2/highgui/highgui.hpp\"\n#include \"opencv2/imgproc/imgproc.hpp\"\n\nusing namespace cv;\nusing namespace std;\n\nvoid getGain ( int l, int m, int n, vector<Mat>& src, Mat& dst, bool verbose)\n\n//****************************************************************************80\n//\n//  Purpose:\n//\n//    getGain computes the z-stack wise quantile of a image position and average across these samples.\n//\n//  Discussion:\n//\n//    On input, the A array contains values of 0 or 1.\n//\n//    The 0 pixels are to be ignored.  The 1 pixels are to be grouped\n\n//\n//  Licensing:\n//\n//    This code is distributed under the GNU LGPL license.\n//\n//  Modified:\n//\n//    23 November 2015\n//\n//  Author:\n//\n//    Daniel Furth\n//\n//  Parameters:\n//\n//    Input, int L, M, N, the order of the array.\n//\n//\n{\n\n  int i;\n  int j;\n  int k;\n\n  int STACKS = l; //number of tiles\n  \n\n//  \"Read\" the array one pixel at a time.\n//\nint barWidth = 70;\n  float progress = 0.0;\n    for ( j = 0; j < m; j++ )\n    {\n      for ( k = 0; k < n; k++ )\n      {\n          \n          std::vector<double> vec;\n        // ... fill vec with values (do not use 0; use 0.0)\n\n          for(size_t s = 0; s != STACKS; ++s){\n            vec.push_back((double)src.at(s).at<ushort>(j,k));\n          }\n          double average = std::accumulate(vec.begin(), vec.end(), 0.0) / vec.size();\n          \n          dst.at<ushort>(j,k) = (int)average;\n      }\n       //print progress bar in console\n     if(verbose){Rcpp::Rcout << \"  [\";\n    int pos = barWidth * progress;\n    for (int p = 0; p < barWidth; ++p) {\n        if (p < pos) Rcpp::Rcout << \"=\";\n        else if (p == pos) Rcpp::Rcout << \">\";\n        else Rcpp::Rcout << \" \";\n    }\n    Rcpp::Rcout << \"] \" << int(progress * 100.0) << \"% \\r\" << std::cout.flush();//cout.flush(); \n    R_FlushConsole();\n    R_ProcessEvents();\n    R_CheckUserInterrupt();\n    progress += (float)1/(m-1);\n    }\n    }\n// \n//\n// \n\n}\n\n\n\n/* apply operation to stack */\nRcppExport SEXP posteriorFFC(SEXP input, SEXP outputfolder, SEXP outname, SEXP kernel, SEXP display,  SEXP outputfile, SEXP writetoconsole) {\nBEGIN_RCPP\n  Rcpp::RNGScope __rngScope; //this and BEGIN_RCPP and END_RCPP is needed for wrappers such as Rcpp::as<int>\n  //Rcpp::CharacterVector std::vector< std::string >\n  Rcpp::CharacterVector f(input);\n  int num_files = f.size();\n\n  Rcpp::CharacterVector outputfilenames(outname);\n\n  Rcpp::CharacterVector outf(outputfolder);\n  std::string outfolder(outf[0]);\n\n  int KERNEL = Rcpp::as<int>(kernel);\n  int DISPLAY = Rcpp::as<int>(display);\n  Rcpp::CharacterVector of(outputfile);\n  std::string off(of[0]);\n\n  bool verbose = Rcpp::as<bool>(writetoconsole);\n\n  int barWidth = 70;\n  float progress = 0.0;\n\n  std::string ff(f[0]);\n  Mat remove = imread(ff, -1);\n  int rows = remove.rows;\n  int cols = remove.cols;\n  vector<Mat> zpositions(num_files,Mat(cols,rows,remove.type()));\n  vector<Mat> destination(num_files,Mat(cols,rows,remove.type()));\n  Mat src;\n  \n  Mat dst = Mat::zeros(remove.size(), remove.type());\n  if(verbose){Rcpp::Rcout << \"Loading \" <<  num_files << \" stacks into RAM.\" << std::endl;}\n  for (int i = 0; i < f.size(); i++){\n    std::string filename(f[i]);\n\n    src = imread(filename, -1);\n    zpositions.at(i) = src;\n\n    \n\n\n    //print progress bar in console\n    if(verbose){Rcpp::Rcout << \"  [\";\n    int pos = barWidth * progress;\n    for (int j = 0; j < barWidth; ++j) {\n        if (j < pos) Rcpp::Rcout << \"=\";\n        else if (j == pos) Rcpp::Rcout << \">\";\n        else Rcpp::Rcout << \" \";\n    }\n    Rcpp::Rcout << \"] \" << int(progress * 100.0) << \"% \\r\" << std::cout.flush();//std::cout.flush();\n    R_FlushConsole();\n    R_ProcessEvents();\n    R_CheckUserInterrupt();\n    progress += (float)1/(num_files-1);\n  }\n\n  }\n  if(verbose){Rcpp::Rcout << \"\\n\" << std::endl;\n  Rcpp::Rcout << \"====== LOADING DONE ======\" << std::endl;\n\n  Rcpp::Rcout << \"Running command. \" << \"generate gain image\" << \" on stack\" << std::endl;}\n  getGain(num_files, cols, rows, zpositions, dst, verbose);\n    // Gaussian smoothing\n  GaussianBlur( dst, dst, Size( KERNEL, KERNEL ), 0, 0 );\n  imwrite(off, dst);\n  if(verbose){  Rcpp::Rcout << \"\\n\" << std::endl;\n    Rcpp::Rcout << \"Gain image saved as: \" << off << std::endl;\n  Rcpp::Rcout << \"====== GAIN IMAGE GENERATED ======\" << std::endl;\n\n  Rcpp::Rcout << \"Running command. \" << \"illumination correction\" << \" on stack\" << std::endl;}\n\n  Mat output;\n\n  barWidth = 70;\n  progress = 0.0;\n for(size_t s = 0; s != num_files; ++s){\n  Scalar meanGain = mean(dst);\n  divide(zpositions.at(s), dst, output, meanGain.val[0]);\n  \n  //multiply(output, meanGain, output);\n  string filename(outputfilenames[s]);\n  string outputname;\n  outputname =  outfolder + \"/\" + \"FFC_\" + filename;\n  imwrite(outputname, output);\n\n  //print progress bar in console\n  if(verbose){  Rcpp::Rcout << \"  [\";\n    int pos = barWidth * progress;\n    for (int j = 0; j < barWidth; ++j) {\n        if (j < pos) Rcpp::Rcout << \"=\";\n        else if (j == pos) Rcpp::Rcout << \">\";\n        else Rcpp::Rcout << \" \";\n    }\n    Rcpp::Rcout << \"] \" << int(progress * 100.0) << \"% \\r\" <<  std::cout.flush();//std::cout.flush();\n    R_FlushConsole();\n    R_ProcessEvents();\n    R_CheckUserInterrupt();\n    progress += (float)1/(num_files-1); }\n\n\n }\n if(verbose){Rcpp::Rcout << \"\\n\" << std::endl;\n Rcpp::Rcout << \"====== OUTPUT SAVED ======\" << std::endl;}\n   /*\n  END\n  */\nEND_RCPP  \n}\n\n\n\n",
    "created" : 1476130078616.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1715293030",
    "id" : "DA365EDB",
    "lastKnownWriteTime" : 1466584492,
    "last_content_update" : 1466584492,
    "path" : "~/GitHub/fisseq/src/flatfieldcorrection.cpp",
    "project_path" : "src/flatfieldcorrection.cpp",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}